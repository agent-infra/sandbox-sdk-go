// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
	big "math/big"
)

var (
	actionResponseFieldActionPerformed = big.NewInt(1 << 0)
)

type ActionResponse struct {
	ActionPerformed string `json:"action_performed" url:"action_performed"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	status         string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionResponse) GetActionPerformed() string {
	if a == nil {
		return ""
	}
	return a.ActionPerformed
}

func (a *ActionResponse) Status() string {
	return a.status
}

func (a *ActionResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetActionPerformed sets the ActionPerformed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetActionPerformed(actionPerformed string) {
	a.ActionPerformed = actionPerformed
	a.require(actionResponseFieldActionPerformed)
}

func (a *ActionResponse) UnmarshalJSON(data []byte) error {
	type embed ActionResponse
	var unmarshaler = struct {
		embed
		Status string `json:"status"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActionResponse(unmarshaler.embed)
	if unmarshaler.Status != "success" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "success", unmarshaler.Status)
	}
	a.status = unmarshaler.Status
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "status")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionResponse) MarshalJSON() ([]byte, error) {
	type embed ActionResponse
	var marshaler = struct {
		embed
		Status string `json:"status"`
	}{
		embed:  embed(*a),
		Status: "success",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Browser Info result
var (
	browserInfoResultFieldUserAgent = big.NewInt(1 << 0)
	browserInfoResultFieldCdpUrl    = big.NewInt(1 << 1)
	browserInfoResultFieldVncUrl    = big.NewInt(1 << 2)
	browserInfoResultFieldViewport  = big.NewInt(1 << 3)
)

type BrowserInfoResult struct {
	// User agent
	UserAgent string `json:"user_agent" url:"user_agent"`
	// Browser CDP URL
	CdpUrl string `json:"cdp_url" url:"cdp_url"`
	// VNC URL
	VncUrl string `json:"vnc_url" url:"vnc_url"`
	// Viewport size
	Viewport *BrowserViewport `json:"viewport" url:"viewport"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BrowserInfoResult) GetUserAgent() string {
	if b == nil {
		return ""
	}
	return b.UserAgent
}

func (b *BrowserInfoResult) GetCdpUrl() string {
	if b == nil {
		return ""
	}
	return b.CdpUrl
}

func (b *BrowserInfoResult) GetVncUrl() string {
	if b == nil {
		return ""
	}
	return b.VncUrl
}

func (b *BrowserInfoResult) GetViewport() *BrowserViewport {
	if b == nil {
		return nil
	}
	return b.Viewport
}

func (b *BrowserInfoResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BrowserInfoResult) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserAgent sets the UserAgent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfoResult) SetUserAgent(userAgent string) {
	b.UserAgent = userAgent
	b.require(browserInfoResultFieldUserAgent)
}

// SetCdpUrl sets the CdpUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfoResult) SetCdpUrl(cdpUrl string) {
	b.CdpUrl = cdpUrl
	b.require(browserInfoResultFieldCdpUrl)
}

// SetVncUrl sets the VncUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfoResult) SetVncUrl(vncUrl string) {
	b.VncUrl = vncUrl
	b.require(browserInfoResultFieldVncUrl)
}

// SetViewport sets the Viewport field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfoResult) SetViewport(viewport *BrowserViewport) {
	b.Viewport = viewport
	b.require(browserInfoResultFieldViewport)
}

func (b *BrowserInfoResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BrowserInfoResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrowserInfoResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrowserInfoResult) MarshalJSON() ([]byte, error) {
	type embed BrowserInfoResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BrowserInfoResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	browserViewportFieldWidth  = big.NewInt(1 << 0)
	browserViewportFieldHeight = big.NewInt(1 << 1)
)

type BrowserViewport struct {
	// Viewport width
	Width int `json:"width" url:"width"`
	// Viewport height
	Height int `json:"height" url:"height"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BrowserViewport) GetWidth() int {
	if b == nil {
		return 0
	}
	return b.Width
}

func (b *BrowserViewport) GetHeight() int {
	if b == nil {
		return 0
	}
	return b.Height
}

func (b *BrowserViewport) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BrowserViewport) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetWidth sets the Width field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserViewport) SetWidth(width int) {
	b.Width = width
	b.require(browserViewportFieldWidth)
}

// SetHeight sets the Height field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserViewport) SetHeight(height int) {
	b.Height = height
	b.require(browserViewportFieldHeight)
}

func (b *BrowserViewport) UnmarshalJSON(data []byte) error {
	type unmarshaler BrowserViewport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrowserViewport(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrowserViewport) MarshalJSON() ([]byte, error) {
	type embed BrowserViewport
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BrowserViewport) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Button string

const (
	ButtonLeft   Button = "left"
	ButtonRight  Button = "right"
	ButtonMiddle Button = "middle"
)

func NewButtonFromString(s string) (Button, error) {
	switch s {
	case "left":
		return ButtonLeft, nil
	case "right":
		return ButtonRight, nil
	case "middle":
		return ButtonMiddle, nil
	}
	var t Button
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b Button) Ptr() *Button {
	return &b
}

var (
	clickActionFieldX         = big.NewInt(1 << 0)
	clickActionFieldY         = big.NewInt(1 << 1)
	clickActionFieldButton    = big.NewInt(1 << 2)
	clickActionFieldNumClicks = big.NewInt(1 << 3)
)

type ClickAction struct {
	X         *float64 `json:"x,omitempty" url:"x,omitempty"`
	Y         *float64 `json:"y,omitempty" url:"y,omitempty"`
	Button    *Button  `json:"button,omitempty" url:"button,omitempty"`
	NumClicks *int     `json:"num_clicks,omitempty" url:"num_clicks,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClickAction) GetX() *float64 {
	if c == nil {
		return nil
	}
	return c.X
}

func (c *ClickAction) GetY() *float64 {
	if c == nil {
		return nil
	}
	return c.Y
}

func (c *ClickAction) GetButton() *Button {
	if c == nil {
		return nil
	}
	return c.Button
}

func (c *ClickAction) GetNumClicks() *int {
	if c == nil {
		return nil
	}
	return c.NumClicks
}

func (c *ClickAction) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClickAction) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetX sets the X field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClickAction) SetX(x *float64) {
	c.X = x
	c.require(clickActionFieldX)
}

// SetY sets the Y field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClickAction) SetY(y *float64) {
	c.Y = y
	c.require(clickActionFieldY)
}

// SetButton sets the Button field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClickAction) SetButton(button *Button) {
	c.Button = button
	c.require(clickActionFieldButton)
}

// SetNumClicks sets the NumClicks field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClickAction) SetNumClicks(numClicks *int) {
	c.NumClicks = numClicks
	c.require(clickActionFieldNumClicks)
}

func (c *ClickAction) UnmarshalJSON(data []byte) error {
	type unmarshaler ClickAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClickAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClickAction) MarshalJSON() ([]byte, error) {
	type embed ClickAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClickAction) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	doubleClickActionFieldX = big.NewInt(1 << 0)
	doubleClickActionFieldY = big.NewInt(1 << 1)
)

type DoubleClickAction struct {
	X *float64 `json:"x,omitempty" url:"x,omitempty"`
	Y *float64 `json:"y,omitempty" url:"y,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DoubleClickAction) GetX() *float64 {
	if d == nil {
		return nil
	}
	return d.X
}

func (d *DoubleClickAction) GetY() *float64 {
	if d == nil {
		return nil
	}
	return d.Y
}

func (d *DoubleClickAction) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DoubleClickAction) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetX sets the X field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleClickAction) SetX(x *float64) {
	d.X = x
	d.require(doubleClickActionFieldX)
}

// SetY sets the Y field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DoubleClickAction) SetY(y *float64) {
	d.Y = y
	d.require(doubleClickActionFieldY)
}

func (d *DoubleClickAction) UnmarshalJSON(data []byte) error {
	type unmarshaler DoubleClickAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DoubleClickAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DoubleClickAction) MarshalJSON() ([]byte, error) {
	type embed DoubleClickAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DoubleClickAction) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	dragRelActionFieldXOffset = big.NewInt(1 << 0)
	dragRelActionFieldYOffset = big.NewInt(1 << 1)
)

type DragRelAction struct {
	// Relative current position x-axis drag movement
	XOffset float64 `json:"x_offset" url:"x_offset"`
	// Relative current position y-axis drag movement
	YOffset float64 `json:"y_offset" url:"y_offset"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DragRelAction) GetXOffset() float64 {
	if d == nil {
		return 0
	}
	return d.XOffset
}

func (d *DragRelAction) GetYOffset() float64 {
	if d == nil {
		return 0
	}
	return d.YOffset
}

func (d *DragRelAction) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DragRelAction) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetXOffset sets the XOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DragRelAction) SetXOffset(xOffset float64) {
	d.XOffset = xOffset
	d.require(dragRelActionFieldXOffset)
}

// SetYOffset sets the YOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DragRelAction) SetYOffset(yOffset float64) {
	d.YOffset = yOffset
	d.require(dragRelActionFieldYOffset)
}

func (d *DragRelAction) UnmarshalJSON(data []byte) error {
	type unmarshaler DragRelAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DragRelAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DragRelAction) MarshalJSON() ([]byte, error) {
	type embed DragRelAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DragRelAction) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	dragToActionFieldX = big.NewInt(1 << 0)
	dragToActionFieldY = big.NewInt(1 << 1)
)

type DragToAction struct {
	// Target x-coordinate for drag
	X float64 `json:"x" url:"x"`
	// Target y-coordinate for drag
	Y float64 `json:"y" url:"y"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DragToAction) GetX() float64 {
	if d == nil {
		return 0
	}
	return d.X
}

func (d *DragToAction) GetY() float64 {
	if d == nil {
		return 0
	}
	return d.Y
}

func (d *DragToAction) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DragToAction) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetX sets the X field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DragToAction) SetX(x float64) {
	d.X = x
	d.require(dragToActionFieldX)
}

// SetY sets the Y field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DragToAction) SetY(y float64) {
	d.Y = y
	d.require(dragToActionFieldY)
}

func (d *DragToAction) UnmarshalJSON(data []byte) error {
	type unmarshaler DragToAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DragToAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DragToAction) MarshalJSON() ([]byte, error) {
	type embed DragToAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DragToAction) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	hotkeyActionFieldKeys = big.NewInt(1 << 0)
)

type HotkeyAction struct {
	Keys []string `json:"keys" url:"keys"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HotkeyAction) GetKeys() []string {
	if h == nil {
		return nil
	}
	return h.Keys
}

func (h *HotkeyAction) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HotkeyAction) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetKeys sets the Keys field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HotkeyAction) SetKeys(keys []string) {
	h.Keys = keys
	h.require(hotkeyActionFieldKeys)
}

func (h *HotkeyAction) UnmarshalJSON(data []byte) error {
	type unmarshaler HotkeyAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HotkeyAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HotkeyAction) MarshalJSON() ([]byte, error) {
	type embed HotkeyAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HotkeyAction) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

var (
	keyDownActionFieldKey = big.NewInt(1 << 0)
)

type KeyDownAction struct {
	Key string `json:"key" url:"key"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyDownAction) GetKey() string {
	if k == nil {
		return ""
	}
	return k.Key
}

func (k *KeyDownAction) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyDownAction) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KeyDownAction) SetKey(key string) {
	k.Key = key
	k.require(keyDownActionFieldKey)
}

func (k *KeyDownAction) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyDownAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyDownAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyDownAction) MarshalJSON() ([]byte, error) {
	type embed KeyDownAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KeyDownAction) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	keyUpActionFieldKey = big.NewInt(1 << 0)
)

type KeyUpAction struct {
	Key string `json:"key" url:"key"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyUpAction) GetKey() string {
	if k == nil {
		return ""
	}
	return k.Key
}

func (k *KeyUpAction) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyUpAction) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KeyUpAction) SetKey(key string) {
	k.Key = key
	k.require(keyUpActionFieldKey)
}

func (k *KeyUpAction) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyUpAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyUpAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyUpAction) MarshalJSON() ([]byte, error) {
	type embed KeyUpAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KeyUpAction) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	mouseDownActionFieldButton = big.NewInt(1 << 0)
)

type MouseDownAction struct {
	Button *Button `json:"button,omitempty" url:"button,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MouseDownAction) GetButton() *Button {
	if m == nil {
		return nil
	}
	return m.Button
}

func (m *MouseDownAction) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MouseDownAction) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetButton sets the Button field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MouseDownAction) SetButton(button *Button) {
	m.Button = button
	m.require(mouseDownActionFieldButton)
}

func (m *MouseDownAction) UnmarshalJSON(data []byte) error {
	type unmarshaler MouseDownAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MouseDownAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MouseDownAction) MarshalJSON() ([]byte, error) {
	type embed MouseDownAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MouseDownAction) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	mouseUpActionFieldButton = big.NewInt(1 << 0)
)

type MouseUpAction struct {
	Button *Button `json:"button,omitempty" url:"button,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MouseUpAction) GetButton() *Button {
	if m == nil {
		return nil
	}
	return m.Button
}

func (m *MouseUpAction) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MouseUpAction) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetButton sets the Button field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MouseUpAction) SetButton(button *Button) {
	m.Button = button
	m.require(mouseUpActionFieldButton)
}

func (m *MouseUpAction) UnmarshalJSON(data []byte) error {
	type unmarshaler MouseUpAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MouseUpAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MouseUpAction) MarshalJSON() ([]byte, error) {
	type embed MouseUpAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MouseUpAction) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	moveRelActionFieldXOffset = big.NewInt(1 << 0)
	moveRelActionFieldYOffset = big.NewInt(1 << 1)
)

type MoveRelAction struct {
	// Relative current position x-axis movement
	XOffset float64 `json:"x_offset" url:"x_offset"`
	// Relative current position y-axis movement
	YOffset float64 `json:"y_offset" url:"y_offset"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MoveRelAction) GetXOffset() float64 {
	if m == nil {
		return 0
	}
	return m.XOffset
}

func (m *MoveRelAction) GetYOffset() float64 {
	if m == nil {
		return 0
	}
	return m.YOffset
}

func (m *MoveRelAction) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MoveRelAction) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetXOffset sets the XOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MoveRelAction) SetXOffset(xOffset float64) {
	m.XOffset = xOffset
	m.require(moveRelActionFieldXOffset)
}

// SetYOffset sets the YOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MoveRelAction) SetYOffset(yOffset float64) {
	m.YOffset = yOffset
	m.require(moveRelActionFieldYOffset)
}

func (m *MoveRelAction) UnmarshalJSON(data []byte) error {
	type unmarshaler MoveRelAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MoveRelAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MoveRelAction) MarshalJSON() ([]byte, error) {
	type embed MoveRelAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MoveRelAction) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	moveToActionFieldX = big.NewInt(1 << 0)
	moveToActionFieldY = big.NewInt(1 << 1)
)

type MoveToAction struct {
	// Target x-coordinate
	X float64 `json:"x" url:"x"`
	// Target y-coordinate
	Y float64 `json:"y" url:"y"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MoveToAction) GetX() float64 {
	if m == nil {
		return 0
	}
	return m.X
}

func (m *MoveToAction) GetY() float64 {
	if m == nil {
		return 0
	}
	return m.Y
}

func (m *MoveToAction) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MoveToAction) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetX sets the X field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MoveToAction) SetX(x float64) {
	m.X = x
	m.require(moveToActionFieldX)
}

// SetY sets the Y field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MoveToAction) SetY(y float64) {
	m.Y = y
	m.require(moveToActionFieldY)
}

func (m *MoveToAction) UnmarshalJSON(data []byte) error {
	type unmarshaler MoveToAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MoveToAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MoveToAction) MarshalJSON() ([]byte, error) {
	type embed MoveToAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MoveToAction) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	pressActionFieldKey = big.NewInt(1 << 0)
)

type PressAction struct {
	Key string `json:"key" url:"key"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PressAction) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *PressAction) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PressAction) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PressAction) SetKey(key string) {
	p.Key = key
	p.require(pressActionFieldKey)
}

func (p *PressAction) UnmarshalJSON(data []byte) error {
	type unmarshaler PressAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PressAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PressAction) MarshalJSON() ([]byte, error) {
	type embed PressAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PressAction) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	responseBrowserInfoResultFieldSuccess = big.NewInt(1 << 0)
	responseBrowserInfoResultFieldMessage = big.NewInt(1 << 1)
	responseBrowserInfoResultFieldData    = big.NewInt(1 << 2)
)

type ResponseBrowserInfoResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *BrowserInfoResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseBrowserInfoResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseBrowserInfoResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseBrowserInfoResult) GetData() *BrowserInfoResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseBrowserInfoResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseBrowserInfoResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseBrowserInfoResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseBrowserInfoResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseBrowserInfoResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseBrowserInfoResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseBrowserInfoResult) SetData(data *BrowserInfoResult) {
	r.Data = data
	r.require(responseBrowserInfoResultFieldData)
}

func (r *ResponseBrowserInfoResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseBrowserInfoResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseBrowserInfoResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseBrowserInfoResult) MarshalJSON() ([]byte, error) {
	type embed ResponseBrowserInfoResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseBrowserInfoResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	rightClickActionFieldX = big.NewInt(1 << 0)
	rightClickActionFieldY = big.NewInt(1 << 1)
)

type RightClickAction struct {
	X *float64 `json:"x,omitempty" url:"x,omitempty"`
	Y *float64 `json:"y,omitempty" url:"y,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RightClickAction) GetX() *float64 {
	if r == nil {
		return nil
	}
	return r.X
}

func (r *RightClickAction) GetY() *float64 {
	if r == nil {
		return nil
	}
	return r.Y
}

func (r *RightClickAction) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RightClickAction) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetX sets the X field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RightClickAction) SetX(x *float64) {
	r.X = x
	r.require(rightClickActionFieldX)
}

// SetY sets the Y field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RightClickAction) SetY(y *float64) {
	r.Y = y
	r.require(rightClickActionFieldY)
}

func (r *RightClickAction) UnmarshalJSON(data []byte) error {
	type unmarshaler RightClickAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RightClickAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RightClickAction) MarshalJSON() ([]byte, error) {
	type embed RightClickAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RightClickAction) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	scrollActionFieldDx = big.NewInt(1 << 0)
	scrollActionFieldDy = big.NewInt(1 << 1)
)

type ScrollAction struct {
	Dx *int `json:"dx,omitempty" url:"dx,omitempty"`
	Dy *int `json:"dy,omitempty" url:"dy,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScrollAction) GetDx() *int {
	if s == nil {
		return nil
	}
	return s.Dx
}

func (s *ScrollAction) GetDy() *int {
	if s == nil {
		return nil
	}
	return s.Dy
}

func (s *ScrollAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScrollAction) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDx sets the Dx field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScrollAction) SetDx(dx *int) {
	s.Dx = dx
	s.require(scrollActionFieldDx)
}

// SetDy sets the Dy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScrollAction) SetDy(dy *int) {
	s.Dy = dy
	s.require(scrollActionFieldDy)
}

func (s *ScrollAction) UnmarshalJSON(data []byte) error {
	type unmarshaler ScrollAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScrollAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScrollAction) MarshalJSON() ([]byte, error) {
	type embed ScrollAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ScrollAction) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	typingActionFieldText         = big.NewInt(1 << 0)
	typingActionFieldUseClipboard = big.NewInt(1 << 1)
)

type TypingAction struct {
	Text string `json:"text" url:"text"`
	// Use clipboard for better character support (recommended for special/ASCII characters)
	UseClipboard *bool `json:"use_clipboard,omitempty" url:"use_clipboard,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TypingAction) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TypingAction) GetUseClipboard() *bool {
	if t == nil {
		return nil
	}
	return t.UseClipboard
}

func (t *TypingAction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TypingAction) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypingAction) SetText(text string) {
	t.Text = text
	t.require(typingActionFieldText)
}

// SetUseClipboard sets the UseClipboard field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TypingAction) SetUseClipboard(useClipboard *bool) {
	t.UseClipboard = useClipboard
	t.require(typingActionFieldUseClipboard)
}

func (t *TypingAction) UnmarshalJSON(data []byte) error {
	type unmarshaler TypingAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TypingAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TypingAction) MarshalJSON() ([]byte, error) {
	type embed TypingAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TypingAction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	waitActionFieldDuration = big.NewInt(1 << 0)
)

type WaitAction struct {
	// Duration to wait in seconds
	Duration float64 `json:"duration" url:"duration"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WaitAction) GetDuration() float64 {
	if w == nil {
		return 0
	}
	return w.Duration
}

func (w *WaitAction) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WaitAction) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetDuration sets the Duration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaitAction) SetDuration(duration float64) {
	w.Duration = duration
	w.require(waitActionFieldDuration)
}

func (w *WaitAction) UnmarshalJSON(data []byte) error {
	type unmarshaler WaitAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WaitAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WaitAction) MarshalJSON() ([]byte, error) {
	type embed WaitAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WaitAction) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type Action struct {
	ActionType  string
	MoveTo      *MoveToAction
	MoveRel     *MoveRelAction
	Click       *ClickAction
	MouseDown   *MouseDownAction
	MouseUp     *MouseUpAction
	RightClick  *RightClickAction
	DoubleClick *DoubleClickAction
	DragTo      *DragToAction
	DragRel     *DragRelAction
	Scroll      *ScrollAction
	Typing      *TypingAction
	Press       *PressAction
	KeyDown     *KeyDownAction
	KeyUp       *KeyUpAction
	Hotkey      *HotkeyAction
	Wait        *WaitAction
}

func (a *Action) GetActionType() string {
	if a == nil {
		return ""
	}
	return a.ActionType
}

func (a *Action) GetMoveTo() *MoveToAction {
	if a == nil {
		return nil
	}
	return a.MoveTo
}

func (a *Action) GetMoveRel() *MoveRelAction {
	if a == nil {
		return nil
	}
	return a.MoveRel
}

func (a *Action) GetClick() *ClickAction {
	if a == nil {
		return nil
	}
	return a.Click
}

func (a *Action) GetMouseDown() *MouseDownAction {
	if a == nil {
		return nil
	}
	return a.MouseDown
}

func (a *Action) GetMouseUp() *MouseUpAction {
	if a == nil {
		return nil
	}
	return a.MouseUp
}

func (a *Action) GetRightClick() *RightClickAction {
	if a == nil {
		return nil
	}
	return a.RightClick
}

func (a *Action) GetDoubleClick() *DoubleClickAction {
	if a == nil {
		return nil
	}
	return a.DoubleClick
}

func (a *Action) GetDragTo() *DragToAction {
	if a == nil {
		return nil
	}
	return a.DragTo
}

func (a *Action) GetDragRel() *DragRelAction {
	if a == nil {
		return nil
	}
	return a.DragRel
}

func (a *Action) GetScroll() *ScrollAction {
	if a == nil {
		return nil
	}
	return a.Scroll
}

func (a *Action) GetTyping() *TypingAction {
	if a == nil {
		return nil
	}
	return a.Typing
}

func (a *Action) GetPress() *PressAction {
	if a == nil {
		return nil
	}
	return a.Press
}

func (a *Action) GetKeyDown() *KeyDownAction {
	if a == nil {
		return nil
	}
	return a.KeyDown
}

func (a *Action) GetKeyUp() *KeyUpAction {
	if a == nil {
		return nil
	}
	return a.KeyUp
}

func (a *Action) GetHotkey() *HotkeyAction {
	if a == nil {
		return nil
	}
	return a.Hotkey
}

func (a *Action) GetWait() *WaitAction {
	if a == nil {
		return nil
	}
	return a.Wait
}

func (a *Action) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ActionType string `json:"action_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.ActionType = unmarshaler.ActionType
	if unmarshaler.ActionType == "" {
		return fmt.Errorf("%T did not include discriminant action_type", a)
	}
	switch unmarshaler.ActionType {
	case "MOVE_TO":
		value := new(MoveToAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MoveTo = value
	case "MOVE_REL":
		value := new(MoveRelAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MoveRel = value
	case "CLICK":
		value := new(ClickAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Click = value
	case "MOUSE_DOWN":
		value := new(MouseDownAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MouseDown = value
	case "MOUSE_UP":
		value := new(MouseUpAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.MouseUp = value
	case "RIGHT_CLICK":
		value := new(RightClickAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.RightClick = value
	case "DOUBLE_CLICK":
		value := new(DoubleClickAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.DoubleClick = value
	case "DRAG_TO":
		value := new(DragToAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.DragTo = value
	case "DRAG_REL":
		value := new(DragRelAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.DragRel = value
	case "SCROLL":
		value := new(ScrollAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Scroll = value
	case "TYPING":
		value := new(TypingAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Typing = value
	case "PRESS":
		value := new(PressAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Press = value
	case "KEY_DOWN":
		value := new(KeyDownAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.KeyDown = value
	case "KEY_UP":
		value := new(KeyUpAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.KeyUp = value
	case "HOTKEY":
		value := new(HotkeyAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Hotkey = value
	case "WAIT":
		value := new(WaitAction)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Wait = value
	}
	return nil
}

func (a Action) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.MoveTo != nil {
		return internal.MarshalJSONWithExtraProperty(a.MoveTo, "action_type", "MOVE_TO")
	}
	if a.MoveRel != nil {
		return internal.MarshalJSONWithExtraProperty(a.MoveRel, "action_type", "MOVE_REL")
	}
	if a.Click != nil {
		return internal.MarshalJSONWithExtraProperty(a.Click, "action_type", "CLICK")
	}
	if a.MouseDown != nil {
		return internal.MarshalJSONWithExtraProperty(a.MouseDown, "action_type", "MOUSE_DOWN")
	}
	if a.MouseUp != nil {
		return internal.MarshalJSONWithExtraProperty(a.MouseUp, "action_type", "MOUSE_UP")
	}
	if a.RightClick != nil {
		return internal.MarshalJSONWithExtraProperty(a.RightClick, "action_type", "RIGHT_CLICK")
	}
	if a.DoubleClick != nil {
		return internal.MarshalJSONWithExtraProperty(a.DoubleClick, "action_type", "DOUBLE_CLICK")
	}
	if a.DragTo != nil {
		return internal.MarshalJSONWithExtraProperty(a.DragTo, "action_type", "DRAG_TO")
	}
	if a.DragRel != nil {
		return internal.MarshalJSONWithExtraProperty(a.DragRel, "action_type", "DRAG_REL")
	}
	if a.Scroll != nil {
		return internal.MarshalJSONWithExtraProperty(a.Scroll, "action_type", "SCROLL")
	}
	if a.Typing != nil {
		return internal.MarshalJSONWithExtraProperty(a.Typing, "action_type", "TYPING")
	}
	if a.Press != nil {
		return internal.MarshalJSONWithExtraProperty(a.Press, "action_type", "PRESS")
	}
	if a.KeyDown != nil {
		return internal.MarshalJSONWithExtraProperty(a.KeyDown, "action_type", "KEY_DOWN")
	}
	if a.KeyUp != nil {
		return internal.MarshalJSONWithExtraProperty(a.KeyUp, "action_type", "KEY_UP")
	}
	if a.Hotkey != nil {
		return internal.MarshalJSONWithExtraProperty(a.Hotkey, "action_type", "HOTKEY")
	}
	if a.Wait != nil {
		return internal.MarshalJSONWithExtraProperty(a.Wait, "action_type", "WAIT")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ActionVisitor interface {
	VisitMoveTo(*MoveToAction) error
	VisitMoveRel(*MoveRelAction) error
	VisitClick(*ClickAction) error
	VisitMouseDown(*MouseDownAction) error
	VisitMouseUp(*MouseUpAction) error
	VisitRightClick(*RightClickAction) error
	VisitDoubleClick(*DoubleClickAction) error
	VisitDragTo(*DragToAction) error
	VisitDragRel(*DragRelAction) error
	VisitScroll(*ScrollAction) error
	VisitTyping(*TypingAction) error
	VisitPress(*PressAction) error
	VisitKeyDown(*KeyDownAction) error
	VisitKeyUp(*KeyUpAction) error
	VisitHotkey(*HotkeyAction) error
	VisitWait(*WaitAction) error
}

func (a *Action) Accept(visitor ActionVisitor) error {
	if a.MoveTo != nil {
		return visitor.VisitMoveTo(a.MoveTo)
	}
	if a.MoveRel != nil {
		return visitor.VisitMoveRel(a.MoveRel)
	}
	if a.Click != nil {
		return visitor.VisitClick(a.Click)
	}
	if a.MouseDown != nil {
		return visitor.VisitMouseDown(a.MouseDown)
	}
	if a.MouseUp != nil {
		return visitor.VisitMouseUp(a.MouseUp)
	}
	if a.RightClick != nil {
		return visitor.VisitRightClick(a.RightClick)
	}
	if a.DoubleClick != nil {
		return visitor.VisitDoubleClick(a.DoubleClick)
	}
	if a.DragTo != nil {
		return visitor.VisitDragTo(a.DragTo)
	}
	if a.DragRel != nil {
		return visitor.VisitDragRel(a.DragRel)
	}
	if a.Scroll != nil {
		return visitor.VisitScroll(a.Scroll)
	}
	if a.Typing != nil {
		return visitor.VisitTyping(a.Typing)
	}
	if a.Press != nil {
		return visitor.VisitPress(a.Press)
	}
	if a.KeyDown != nil {
		return visitor.VisitKeyDown(a.KeyDown)
	}
	if a.KeyUp != nil {
		return visitor.VisitKeyUp(a.KeyUp)
	}
	if a.Hotkey != nil {
		return visitor.VisitHotkey(a.Hotkey)
	}
	if a.Wait != nil {
		return visitor.VisitWait(a.Wait)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *Action) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.MoveTo != nil {
		fields = append(fields, "MOVE_TO")
	}
	if a.MoveRel != nil {
		fields = append(fields, "MOVE_REL")
	}
	if a.Click != nil {
		fields = append(fields, "CLICK")
	}
	if a.MouseDown != nil {
		fields = append(fields, "MOUSE_DOWN")
	}
	if a.MouseUp != nil {
		fields = append(fields, "MOUSE_UP")
	}
	if a.RightClick != nil {
		fields = append(fields, "RIGHT_CLICK")
	}
	if a.DoubleClick != nil {
		fields = append(fields, "DOUBLE_CLICK")
	}
	if a.DragTo != nil {
		fields = append(fields, "DRAG_TO")
	}
	if a.DragRel != nil {
		fields = append(fields, "DRAG_REL")
	}
	if a.Scroll != nil {
		fields = append(fields, "SCROLL")
	}
	if a.Typing != nil {
		fields = append(fields, "TYPING")
	}
	if a.Press != nil {
		fields = append(fields, "PRESS")
	}
	if a.KeyDown != nil {
		fields = append(fields, "KEY_DOWN")
	}
	if a.KeyUp != nil {
		fields = append(fields, "KEY_UP")
	}
	if a.Hotkey != nil {
		fields = append(fields, "HOTKEY")
	}
	if a.Wait != nil {
		fields = append(fields, "WAIT")
	}
	if len(fields) == 0 {
		if a.ActionType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.ActionType)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.ActionType != "" {
		field := fields[0]
		if a.ActionType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.ActionType,
				a,
			)
		}
	}
	return nil
}
