// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
	io "io"
	big "math/big"
)

var (
	fileDownloadFileRequestFieldPath = big.NewInt(1 << 0)
)

type FileDownloadFileRequest struct {
	Path string `json:"-" url:"path"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileDownloadFileRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileDownloadFileRequest) SetPath(path string) {
	f.Path = path
	f.require(fileDownloadFileRequestFieldPath)
}

var (
	fileFindRequestFieldPath = big.NewInt(1 << 0)
	fileFindRequestFieldGlob = big.NewInt(1 << 1)
)

type FileFindRequest struct {
	// Directory path to search
	Path string `json:"path" url:"-"`
	// Filename pattern (glob syntax)
	Glob string `json:"glob" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileFindRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileFindRequest) SetPath(path string) {
	f.Path = path
	f.require(fileFindRequestFieldPath)
}

// SetGlob sets the Glob field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileFindRequest) SetGlob(glob string) {
	f.Glob = glob
	f.require(fileFindRequestFieldGlob)
}

var (
	fileListRequestFieldPath               = big.NewInt(1 << 0)
	fileListRequestFieldRecursive          = big.NewInt(1 << 1)
	fileListRequestFieldShowHidden         = big.NewInt(1 << 2)
	fileListRequestFieldFileTypes          = big.NewInt(1 << 3)
	fileListRequestFieldMaxDepth           = big.NewInt(1 << 4)
	fileListRequestFieldIncludeSize        = big.NewInt(1 << 5)
	fileListRequestFieldIncludePermissions = big.NewInt(1 << 6)
	fileListRequestFieldSortBy             = big.NewInt(1 << 7)
	fileListRequestFieldSortDesc           = big.NewInt(1 << 8)
)

type FileListRequest struct {
	// Directory path to list
	Path string `json:"path" url:"-"`
	// Whether to list recursively
	Recursive *bool `json:"recursive,omitempty" url:"-"`
	// Whether to show hidden files
	ShowHidden *bool `json:"show_hidden,omitempty" url:"-"`
	// Filter by file extensions (e.g., ['.py', '.txt'])
	FileTypes []string `json:"file_types,omitempty" url:"-"`
	// Maximum depth for recursive listing
	MaxDepth *int `json:"max_depth,omitempty" url:"-"`
	// Whether to include file size information
	IncludeSize *bool `json:"include_size,omitempty" url:"-"`
	// Whether to include file permissions
	IncludePermissions *bool `json:"include_permissions,omitempty" url:"-"`
	// Sort by: name, size, modified, type
	SortBy *string `json:"sort_by,omitempty" url:"-"`
	// Sort in descending order
	SortDesc *bool `json:"sort_desc,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileListRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetPath(path string) {
	f.Path = path
	f.require(fileListRequestFieldPath)
}

// SetRecursive sets the Recursive field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetRecursive(recursive *bool) {
	f.Recursive = recursive
	f.require(fileListRequestFieldRecursive)
}

// SetShowHidden sets the ShowHidden field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetShowHidden(showHidden *bool) {
	f.ShowHidden = showHidden
	f.require(fileListRequestFieldShowHidden)
}

// SetFileTypes sets the FileTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetFileTypes(fileTypes []string) {
	f.FileTypes = fileTypes
	f.require(fileListRequestFieldFileTypes)
}

// SetMaxDepth sets the MaxDepth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetMaxDepth(maxDepth *int) {
	f.MaxDepth = maxDepth
	f.require(fileListRequestFieldMaxDepth)
}

// SetIncludeSize sets the IncludeSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetIncludeSize(includeSize *bool) {
	f.IncludeSize = includeSize
	f.require(fileListRequestFieldIncludeSize)
}

// SetIncludePermissions sets the IncludePermissions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetIncludePermissions(includePermissions *bool) {
	f.IncludePermissions = includePermissions
	f.require(fileListRequestFieldIncludePermissions)
}

// SetSortBy sets the SortBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetSortBy(sortBy *string) {
	f.SortBy = sortBy
	f.require(fileListRequestFieldSortBy)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListRequest) SetSortDesc(sortDesc *bool) {
	f.SortDesc = sortDesc
	f.require(fileListRequestFieldSortDesc)
}

var (
	fileReadRequestFieldFile      = big.NewInt(1 << 0)
	fileReadRequestFieldStartLine = big.NewInt(1 << 1)
	fileReadRequestFieldEndLine   = big.NewInt(1 << 2)
	fileReadRequestFieldSudo      = big.NewInt(1 << 3)
)

type FileReadRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Start line (0-based)
	StartLine *int `json:"start_line,omitempty" url:"-"`
	// End line (not inclusive)
	EndLine *int `json:"end_line,omitempty" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileReadRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReadRequest) SetFile(file string) {
	f.File = file
	f.require(fileReadRequestFieldFile)
}

// SetStartLine sets the StartLine field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReadRequest) SetStartLine(startLine *int) {
	f.StartLine = startLine
	f.require(fileReadRequestFieldStartLine)
}

// SetEndLine sets the EndLine field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReadRequest) SetEndLine(endLine *int) {
	f.EndLine = endLine
	f.require(fileReadRequestFieldEndLine)
}

// SetSudo sets the Sudo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReadRequest) SetSudo(sudo *bool) {
	f.Sudo = sudo
	f.require(fileReadRequestFieldSudo)
}

var (
	fileReplaceRequestFieldFile   = big.NewInt(1 << 0)
	fileReplaceRequestFieldOldStr = big.NewInt(1 << 1)
	fileReplaceRequestFieldNewStr = big.NewInt(1 << 2)
	fileReplaceRequestFieldSudo   = big.NewInt(1 << 3)
)

type FileReplaceRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Original string to replace
	OldStr string `json:"old_str" url:"-"`
	// New string to replace with
	NewStr string `json:"new_str" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileReplaceRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReplaceRequest) SetFile(file string) {
	f.File = file
	f.require(fileReplaceRequestFieldFile)
}

// SetOldStr sets the OldStr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReplaceRequest) SetOldStr(oldStr string) {
	f.OldStr = oldStr
	f.require(fileReplaceRequestFieldOldStr)
}

// SetNewStr sets the NewStr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReplaceRequest) SetNewStr(newStr string) {
	f.NewStr = newStr
	f.require(fileReplaceRequestFieldNewStr)
}

// SetSudo sets the Sudo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReplaceRequest) SetSudo(sudo *bool) {
	f.Sudo = sudo
	f.require(fileReplaceRequestFieldSudo)
}

var (
	fileSearchRequestFieldFile  = big.NewInt(1 << 0)
	fileSearchRequestFieldRegex = big.NewInt(1 << 1)
	fileSearchRequestFieldSudo  = big.NewInt(1 << 2)
)

type FileSearchRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Regular expression pattern
	Regex string `json:"regex" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileSearchRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileSearchRequest) SetFile(file string) {
	f.File = file
	f.require(fileSearchRequestFieldFile)
}

// SetRegex sets the Regex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileSearchRequest) SetRegex(regex string) {
	f.Regex = regex
	f.require(fileSearchRequestFieldRegex)
}

// SetSudo sets the Sudo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileSearchRequest) SetSudo(sudo *bool) {
	f.Sudo = sudo
	f.require(fileSearchRequestFieldSudo)
}

var (
	strReplaceEditorRequestFieldCommand     = big.NewInt(1 << 0)
	strReplaceEditorRequestFieldPath        = big.NewInt(1 << 1)
	strReplaceEditorRequestFieldFileText    = big.NewInt(1 << 2)
	strReplaceEditorRequestFieldOldStr      = big.NewInt(1 << 3)
	strReplaceEditorRequestFieldNewStr      = big.NewInt(1 << 4)
	strReplaceEditorRequestFieldInsertLine  = big.NewInt(1 << 5)
	strReplaceEditorRequestFieldViewRange   = big.NewInt(1 << 6)
	strReplaceEditorRequestFieldReplaceMode = big.NewInt(1 << 7)
)

type StrReplaceEditorRequest struct {
	// The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.
	Command Command `json:"command" url:"-"`
	// Absolute path to file or directory, e.g. `/workspace/file.py` or `/workspace`.
	Path string `json:"path" url:"-"`
	// Required parameter of `create` command, with the content of the file to be created.
	FileText *string `json:"file_text,omitempty" url:"-"`
	// Required parameter of `str_replace` command containing the string in `path` to replace.
	OldStr *string `json:"old_str,omitempty" url:"-"`
	// Optional parameter of `str_replace` command containing the new string (if not given, no string will be added). Required parameter of `insert` command containing the string to insert.
	NewStr *string `json:"new_str,omitempty" url:"-"`
	// Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.
	InsertLine *int `json:"insert_line,omitempty" url:"-"`
	// Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.
	ViewRange []int `json:"view_range,omitempty" url:"-"`
	// Optional parameter of `str_replace` command. When specified, controls how multiple occurrences are handled: 'ALL' replaces all occurrences, 'FIRST' replaces only the first, 'LAST' replaces only the last. If not specified, requires unique match (original behavior).
	ReplaceMode *StrReplaceEditorRequestReplaceMode `json:"replace_mode,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StrReplaceEditorRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetCommand sets the Command field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetCommand(command Command) {
	s.Command = command
	s.require(strReplaceEditorRequestFieldCommand)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetPath(path string) {
	s.Path = path
	s.require(strReplaceEditorRequestFieldPath)
}

// SetFileText sets the FileText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetFileText(fileText *string) {
	s.FileText = fileText
	s.require(strReplaceEditorRequestFieldFileText)
}

// SetOldStr sets the OldStr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetOldStr(oldStr *string) {
	s.OldStr = oldStr
	s.require(strReplaceEditorRequestFieldOldStr)
}

// SetNewStr sets the NewStr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetNewStr(newStr *string) {
	s.NewStr = newStr
	s.require(strReplaceEditorRequestFieldNewStr)
}

// SetInsertLine sets the InsertLine field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetInsertLine(insertLine *int) {
	s.InsertLine = insertLine
	s.require(strReplaceEditorRequestFieldInsertLine)
}

// SetViewRange sets the ViewRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetViewRange(viewRange []int) {
	s.ViewRange = viewRange
	s.require(strReplaceEditorRequestFieldViewRange)
}

// SetReplaceMode sets the ReplaceMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorRequest) SetReplaceMode(replaceMode *StrReplaceEditorRequestReplaceMode) {
	s.ReplaceMode = replaceMode
	s.require(strReplaceEditorRequestFieldReplaceMode)
}

// File content encoding type
type FileContentEncoding string

const (
	FileContentEncodingUtf8   FileContentEncoding = "utf-8"
	FileContentEncodingBase64 FileContentEncoding = "base64"
	FileContentEncodingRaw    FileContentEncoding = "raw"
)

func NewFileContentEncodingFromString(s string) (FileContentEncoding, error) {
	switch s {
	case "utf-8":
		return FileContentEncodingUtf8, nil
	case "base64":
		return FileContentEncodingBase64, nil
	case "raw":
		return FileContentEncodingRaw, nil
	}
	var t FileContentEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileContentEncoding) Ptr() *FileContentEncoding {
	return &f
}

// File find result
var (
	fileFindResultFieldPath  = big.NewInt(1 << 0)
	fileFindResultFieldFiles = big.NewInt(1 << 1)
)

type FileFindResult struct {
	// Path of the search directory
	Path string `json:"path" url:"path"`
	// List of found files
	Files []string `json:"files,omitempty" url:"files,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileFindResult) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

func (f *FileFindResult) GetFiles() []string {
	if f == nil {
		return nil
	}
	return f.Files
}

func (f *FileFindResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileFindResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileFindResult) SetPath(path string) {
	f.Path = path
	f.require(fileFindResultFieldPath)
}

// SetFiles sets the Files field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileFindResult) SetFiles(files []string) {
	f.Files = files
	f.require(fileFindResultFieldFiles)
}

func (f *FileFindResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileFindResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileFindResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileFindResult) MarshalJSON() ([]byte, error) {
	type embed FileFindResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileFindResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File information
var (
	fileInfoFieldName         = big.NewInt(1 << 0)
	fileInfoFieldPath         = big.NewInt(1 << 1)
	fileInfoFieldIsDirectory  = big.NewInt(1 << 2)
	fileInfoFieldSize         = big.NewInt(1 << 3)
	fileInfoFieldModifiedTime = big.NewInt(1 << 4)
	fileInfoFieldPermissions  = big.NewInt(1 << 5)
	fileInfoFieldExtension    = big.NewInt(1 << 6)
)

type FileInfo struct {
	// File name
	Name string `json:"name" url:"name"`
	// Full file path
	Path string `json:"path" url:"path"`
	// Whether it's a directory
	IsDirectory bool `json:"is_directory" url:"is_directory"`
	// File size in bytes
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Last modified time (ISO format)
	ModifiedTime *string `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// File permissions
	Permissions *string `json:"permissions,omitempty" url:"permissions,omitempty"`
	// File extension
	Extension *string `json:"extension,omitempty" url:"extension,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileInfo) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *FileInfo) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

func (f *FileInfo) GetIsDirectory() bool {
	if f == nil {
		return false
	}
	return f.IsDirectory
}

func (f *FileInfo) GetSize() *int {
	if f == nil {
		return nil
	}
	return f.Size
}

func (f *FileInfo) GetModifiedTime() *string {
	if f == nil {
		return nil
	}
	return f.ModifiedTime
}

func (f *FileInfo) GetPermissions() *string {
	if f == nil {
		return nil
	}
	return f.Permissions
}

func (f *FileInfo) GetExtension() *string {
	if f == nil {
		return nil
	}
	return f.Extension
}

func (f *FileInfo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileInfo) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileInfo) SetName(name string) {
	f.Name = name
	f.require(fileInfoFieldName)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileInfo) SetPath(path string) {
	f.Path = path
	f.require(fileInfoFieldPath)
}

// SetIsDirectory sets the IsDirectory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileInfo) SetIsDirectory(isDirectory bool) {
	f.IsDirectory = isDirectory
	f.require(fileInfoFieldIsDirectory)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileInfo) SetSize(size *int) {
	f.Size = size
	f.require(fileInfoFieldSize)
}

// SetModifiedTime sets the ModifiedTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileInfo) SetModifiedTime(modifiedTime *string) {
	f.ModifiedTime = modifiedTime
	f.require(fileInfoFieldModifiedTime)
}

// SetPermissions sets the Permissions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileInfo) SetPermissions(permissions *string) {
	f.Permissions = permissions
	f.require(fileInfoFieldPermissions)
}

// SetExtension sets the Extension field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileInfo) SetExtension(extension *string) {
	f.Extension = extension
	f.require(fileInfoFieldExtension)
}

func (f *FileInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FileInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileInfo) MarshalJSON() ([]byte, error) {
	type embed FileInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileInfo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File list result
var (
	fileListResultFieldPath           = big.NewInt(1 << 0)
	fileListResultFieldFiles          = big.NewInt(1 << 1)
	fileListResultFieldTotalCount     = big.NewInt(1 << 2)
	fileListResultFieldDirectoryCount = big.NewInt(1 << 3)
	fileListResultFieldFileCount      = big.NewInt(1 << 4)
)

type FileListResult struct {
	// Listed directory path
	Path string `json:"path" url:"path"`
	// List of files and directories
	Files []*FileInfo `json:"files,omitempty" url:"files,omitempty"`
	// Total number of items
	TotalCount *int `json:"total_count,omitempty" url:"total_count,omitempty"`
	// Number of directories
	DirectoryCount *int `json:"directory_count,omitempty" url:"directory_count,omitempty"`
	// Number of files
	FileCount *int `json:"file_count,omitempty" url:"file_count,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileListResult) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

func (f *FileListResult) GetFiles() []*FileInfo {
	if f == nil {
		return nil
	}
	return f.Files
}

func (f *FileListResult) GetTotalCount() *int {
	if f == nil {
		return nil
	}
	return f.TotalCount
}

func (f *FileListResult) GetDirectoryCount() *int {
	if f == nil {
		return nil
	}
	return f.DirectoryCount
}

func (f *FileListResult) GetFileCount() *int {
	if f == nil {
		return nil
	}
	return f.FileCount
}

func (f *FileListResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileListResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListResult) SetPath(path string) {
	f.Path = path
	f.require(fileListResultFieldPath)
}

// SetFiles sets the Files field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListResult) SetFiles(files []*FileInfo) {
	f.Files = files
	f.require(fileListResultFieldFiles)
}

// SetTotalCount sets the TotalCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListResult) SetTotalCount(totalCount *int) {
	f.TotalCount = totalCount
	f.require(fileListResultFieldTotalCount)
}

// SetDirectoryCount sets the DirectoryCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListResult) SetDirectoryCount(directoryCount *int) {
	f.DirectoryCount = directoryCount
	f.require(fileListResultFieldDirectoryCount)
}

// SetFileCount sets the FileCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileListResult) SetFileCount(fileCount *int) {
	f.FileCount = fileCount
	f.require(fileListResultFieldFileCount)
}

func (f *FileListResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileListResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileListResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileListResult) MarshalJSON() ([]byte, error) {
	type embed FileListResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileListResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File read result
var (
	fileReadResultFieldContent = big.NewInt(1 << 0)
	fileReadResultFieldFile    = big.NewInt(1 << 1)
)

type FileReadResult struct {
	// File content
	Content string `json:"content" url:"content"`
	// Path of the read file
	File string `json:"file" url:"file"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileReadResult) GetContent() string {
	if f == nil {
		return ""
	}
	return f.Content
}

func (f *FileReadResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileReadResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileReadResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReadResult) SetContent(content string) {
	f.Content = content
	f.require(fileReadResultFieldContent)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReadResult) SetFile(file string) {
	f.File = file
	f.require(fileReadResultFieldFile)
}

func (f *FileReadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileReadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileReadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileReadResult) MarshalJSON() ([]byte, error) {
	type embed FileReadResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileReadResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File content replacement result
var (
	fileReplaceResultFieldFile          = big.NewInt(1 << 0)
	fileReplaceResultFieldReplacedCount = big.NewInt(1 << 1)
)

type FileReplaceResult struct {
	// Path of the operated file
	File string `json:"file" url:"file"`
	// Number of replacements
	ReplacedCount *int `json:"replaced_count,omitempty" url:"replaced_count,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileReplaceResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileReplaceResult) GetReplacedCount() *int {
	if f == nil {
		return nil
	}
	return f.ReplacedCount
}

func (f *FileReplaceResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileReplaceResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReplaceResult) SetFile(file string) {
	f.File = file
	f.require(fileReplaceResultFieldFile)
}

// SetReplacedCount sets the ReplacedCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileReplaceResult) SetReplacedCount(replacedCount *int) {
	f.ReplacedCount = replacedCount
	f.require(fileReplaceResultFieldReplacedCount)
}

func (f *FileReplaceResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileReplaceResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileReplaceResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileReplaceResult) MarshalJSON() ([]byte, error) {
	type embed FileReplaceResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileReplaceResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File content search result
var (
	fileSearchResultFieldFile        = big.NewInt(1 << 0)
	fileSearchResultFieldMatches     = big.NewInt(1 << 1)
	fileSearchResultFieldLineNumbers = big.NewInt(1 << 2)
)

type FileSearchResult struct {
	// Path of the searched file
	File string `json:"file" url:"file"`
	// List of matched content
	Matches []string `json:"matches,omitempty" url:"matches,omitempty"`
	// List of matched line numbers
	LineNumbers []int `json:"line_numbers,omitempty" url:"line_numbers,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileSearchResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileSearchResult) GetMatches() []string {
	if f == nil {
		return nil
	}
	return f.Matches
}

func (f *FileSearchResult) GetLineNumbers() []int {
	if f == nil {
		return nil
	}
	return f.LineNumbers
}

func (f *FileSearchResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileSearchResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileSearchResult) SetFile(file string) {
	f.File = file
	f.require(fileSearchResultFieldFile)
}

// SetMatches sets the Matches field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileSearchResult) SetMatches(matches []string) {
	f.Matches = matches
	f.require(fileSearchResultFieldMatches)
}

// SetLineNumbers sets the LineNumbers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileSearchResult) SetLineNumbers(lineNumbers []int) {
	f.LineNumbers = lineNumbers
	f.require(fileSearchResultFieldLineNumbers)
}

func (f *FileSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileSearchResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileSearchResult) MarshalJSON() ([]byte, error) {
	type embed FileSearchResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileSearchResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File upload result
var (
	fileUploadResultFieldFilePath = big.NewInt(1 << 0)
	fileUploadResultFieldFileSize = big.NewInt(1 << 1)
	fileUploadResultFieldSuccess  = big.NewInt(1 << 2)
)

type FileUploadResult struct {
	// Path of the uploaded file
	FilePath string `json:"file_path" url:"file_path"`
	// Size of the uploaded file in bytes
	FileSize int `json:"file_size" url:"file_size"`
	// Whether upload was successful
	Success bool `json:"success" url:"success"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileUploadResult) GetFilePath() string {
	if f == nil {
		return ""
	}
	return f.FilePath
}

func (f *FileUploadResult) GetFileSize() int {
	if f == nil {
		return 0
	}
	return f.FileSize
}

func (f *FileUploadResult) GetSuccess() bool {
	if f == nil {
		return false
	}
	return f.Success
}

func (f *FileUploadResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFilePath sets the FilePath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileUploadResult) SetFilePath(filePath string) {
	f.FilePath = filePath
	f.require(fileUploadResultFieldFilePath)
}

// SetFileSize sets the FileSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileUploadResult) SetFileSize(fileSize int) {
	f.FileSize = fileSize
	f.require(fileUploadResultFieldFileSize)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileUploadResult) SetSuccess(success bool) {
	f.Success = success
	f.require(fileUploadResultFieldSuccess)
}

func (f *FileUploadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileUploadResult) MarshalJSON() ([]byte, error) {
	type embed FileUploadResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileUploadResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// File write result
var (
	fileWriteResultFieldFile         = big.NewInt(1 << 0)
	fileWriteResultFieldBytesWritten = big.NewInt(1 << 1)
)

type FileWriteResult struct {
	// Path of the written file
	File string `json:"file" url:"file"`
	// Number of bytes written
	BytesWritten *int `json:"bytes_written,omitempty" url:"bytes_written,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileWriteResult) GetFile() string {
	if f == nil {
		return ""
	}
	return f.File
}

func (f *FileWriteResult) GetBytesWritten() *int {
	if f == nil {
		return nil
	}
	return f.BytesWritten
}

func (f *FileWriteResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileWriteResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteResult) SetFile(file string) {
	f.File = file
	f.require(fileWriteResultFieldFile)
}

// SetBytesWritten sets the BytesWritten field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteResult) SetBytesWritten(bytesWritten *int) {
	f.BytesWritten = bytesWritten
	f.require(fileWriteResultFieldBytesWritten)
}

func (f *FileWriteResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FileWriteResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileWriteResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileWriteResult) MarshalJSON() ([]byte, error) {
	type embed FileWriteResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FileWriteResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	responseFileFindResultFieldSuccess = big.NewInt(1 << 0)
	responseFileFindResultFieldMessage = big.NewInt(1 << 1)
	responseFileFindResultFieldData    = big.NewInt(1 << 2)
)

type ResponseFileFindResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileFindResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileFindResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileFindResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileFindResult) GetData() *FileFindResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileFindResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileFindResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileFindResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFileFindResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileFindResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseFileFindResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileFindResult) SetData(data *FileFindResult) {
	r.Data = data
	r.require(responseFileFindResultFieldData)
}

func (r *ResponseFileFindResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileFindResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileFindResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileFindResult) MarshalJSON() ([]byte, error) {
	type embed ResponseFileFindResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseFileFindResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseFileListResultFieldSuccess = big.NewInt(1 << 0)
	responseFileListResultFieldMessage = big.NewInt(1 << 1)
	responseFileListResultFieldData    = big.NewInt(1 << 2)
)

type ResponseFileListResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileListResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileListResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileListResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileListResult) GetData() *FileListResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileListResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileListResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileListResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFileListResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileListResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseFileListResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileListResult) SetData(data *FileListResult) {
	r.Data = data
	r.require(responseFileListResultFieldData)
}

func (r *ResponseFileListResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileListResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileListResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileListResult) MarshalJSON() ([]byte, error) {
	type embed ResponseFileListResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseFileListResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseFileReadResultFieldSuccess = big.NewInt(1 << 0)
	responseFileReadResultFieldMessage = big.NewInt(1 << 1)
	responseFileReadResultFieldData    = big.NewInt(1 << 2)
)

type ResponseFileReadResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileReadResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileReadResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileReadResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileReadResult) GetData() *FileReadResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileReadResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileReadResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileReadResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFileReadResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileReadResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseFileReadResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileReadResult) SetData(data *FileReadResult) {
	r.Data = data
	r.require(responseFileReadResultFieldData)
}

func (r *ResponseFileReadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileReadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileReadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileReadResult) MarshalJSON() ([]byte, error) {
	type embed ResponseFileReadResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseFileReadResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseFileReplaceResultFieldSuccess = big.NewInt(1 << 0)
	responseFileReplaceResultFieldMessage = big.NewInt(1 << 1)
	responseFileReplaceResultFieldData    = big.NewInt(1 << 2)
)

type ResponseFileReplaceResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileReplaceResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileReplaceResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileReplaceResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileReplaceResult) GetData() *FileReplaceResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileReplaceResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileReplaceResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileReplaceResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFileReplaceResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileReplaceResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseFileReplaceResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileReplaceResult) SetData(data *FileReplaceResult) {
	r.Data = data
	r.require(responseFileReplaceResultFieldData)
}

func (r *ResponseFileReplaceResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileReplaceResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileReplaceResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileReplaceResult) MarshalJSON() ([]byte, error) {
	type embed ResponseFileReplaceResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseFileReplaceResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseFileSearchResultFieldSuccess = big.NewInt(1 << 0)
	responseFileSearchResultFieldMessage = big.NewInt(1 << 1)
	responseFileSearchResultFieldData    = big.NewInt(1 << 2)
)

type ResponseFileSearchResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileSearchResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileSearchResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileSearchResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileSearchResult) GetData() *FileSearchResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileSearchResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileSearchResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileSearchResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFileSearchResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileSearchResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseFileSearchResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileSearchResult) SetData(data *FileSearchResult) {
	r.Data = data
	r.require(responseFileSearchResultFieldData)
}

func (r *ResponseFileSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileSearchResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileSearchResult) MarshalJSON() ([]byte, error) {
	type embed ResponseFileSearchResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseFileSearchResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseFileUploadResultFieldSuccess = big.NewInt(1 << 0)
	responseFileUploadResultFieldMessage = big.NewInt(1 << 1)
	responseFileUploadResultFieldData    = big.NewInt(1 << 2)
)

type ResponseFileUploadResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileUploadResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileUploadResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileUploadResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileUploadResult) GetData() *FileUploadResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileUploadResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileUploadResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileUploadResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFileUploadResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileUploadResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseFileUploadResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileUploadResult) SetData(data *FileUploadResult) {
	r.Data = data
	r.require(responseFileUploadResultFieldData)
}

func (r *ResponseFileUploadResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileUploadResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileUploadResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileUploadResult) MarshalJSON() ([]byte, error) {
	type embed ResponseFileUploadResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseFileUploadResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseFileWriteResultFieldSuccess = big.NewInt(1 << 0)
	responseFileWriteResultFieldMessage = big.NewInt(1 << 1)
	responseFileWriteResultFieldData    = big.NewInt(1 << 2)
)

type ResponseFileWriteResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *FileWriteResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseFileWriteResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseFileWriteResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseFileWriteResult) GetData() *FileWriteResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseFileWriteResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseFileWriteResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileWriteResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFileWriteResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileWriteResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseFileWriteResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseFileWriteResult) SetData(data *FileWriteResult) {
	r.Data = data
	r.require(responseFileWriteResultFieldData)
}

func (r *ResponseFileWriteResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseFileWriteResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseFileWriteResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseFileWriteResult) MarshalJSON() ([]byte, error) {
	type embed ResponseFileWriteResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseFileWriteResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseStrReplaceEditorResultFieldSuccess = big.NewInt(1 << 0)
	responseStrReplaceEditorResultFieldMessage = big.NewInt(1 << 1)
	responseStrReplaceEditorResultFieldData    = big.NewInt(1 << 2)
)

type ResponseStrReplaceEditorResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *StrReplaceEditorResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseStrReplaceEditorResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseStrReplaceEditorResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseStrReplaceEditorResult) GetData() *StrReplaceEditorResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseStrReplaceEditorResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseStrReplaceEditorResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseStrReplaceEditorResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseStrReplaceEditorResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseStrReplaceEditorResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseStrReplaceEditorResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseStrReplaceEditorResult) SetData(data *StrReplaceEditorResult) {
	r.Data = data
	r.require(responseStrReplaceEditorResultFieldData)
}

func (r *ResponseStrReplaceEditorResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseStrReplaceEditorResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseStrReplaceEditorResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseStrReplaceEditorResult) MarshalJSON() ([]byte, error) {
	type embed ResponseStrReplaceEditorResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseStrReplaceEditorResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// String replace editor result based on openhands_aci CLIResult
var (
	strReplaceEditorResultFieldOutput     = big.NewInt(1 << 0)
	strReplaceEditorResultFieldError      = big.NewInt(1 << 1)
	strReplaceEditorResultFieldPath       = big.NewInt(1 << 2)
	strReplaceEditorResultFieldPrevExist  = big.NewInt(1 << 3)
	strReplaceEditorResultFieldOldContent = big.NewInt(1 << 4)
	strReplaceEditorResultFieldNewContent = big.NewInt(1 << 5)
)

type StrReplaceEditorResult struct {
	// Command execution output
	Output string `json:"output" url:"output"`
	// Error message if any
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// File path that was operated on
	Path string `json:"path" url:"path"`
	// Whether the file existed before operation
	PrevExist bool `json:"prev_exist" url:"prev_exist"`
	// Previous file content
	OldContent *string `json:"old_content,omitempty" url:"old_content,omitempty"`
	// New file content after operation
	NewContent *string `json:"new_content,omitempty" url:"new_content,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StrReplaceEditorResult) GetOutput() string {
	if s == nil {
		return ""
	}
	return s.Output
}

func (s *StrReplaceEditorResult) GetError() *string {
	if s == nil {
		return nil
	}
	return s.Error
}

func (s *StrReplaceEditorResult) GetPath() string {
	if s == nil {
		return ""
	}
	return s.Path
}

func (s *StrReplaceEditorResult) GetPrevExist() bool {
	if s == nil {
		return false
	}
	return s.PrevExist
}

func (s *StrReplaceEditorResult) GetOldContent() *string {
	if s == nil {
		return nil
	}
	return s.OldContent
}

func (s *StrReplaceEditorResult) GetNewContent() *string {
	if s == nil {
		return nil
	}
	return s.NewContent
}

func (s *StrReplaceEditorResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StrReplaceEditorResult) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOutput sets the Output field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorResult) SetOutput(output string) {
	s.Output = output
	s.require(strReplaceEditorResultFieldOutput)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorResult) SetError(error_ *string) {
	s.Error = error_
	s.require(strReplaceEditorResultFieldError)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorResult) SetPath(path string) {
	s.Path = path
	s.require(strReplaceEditorResultFieldPath)
}

// SetPrevExist sets the PrevExist field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorResult) SetPrevExist(prevExist bool) {
	s.PrevExist = prevExist
	s.require(strReplaceEditorResultFieldPrevExist)
}

// SetOldContent sets the OldContent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorResult) SetOldContent(oldContent *string) {
	s.OldContent = oldContent
	s.require(strReplaceEditorResultFieldOldContent)
}

// SetNewContent sets the NewContent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StrReplaceEditorResult) SetNewContent(newContent *string) {
	s.NewContent = newContent
	s.require(strReplaceEditorResultFieldNewContent)
}

func (s *StrReplaceEditorResult) UnmarshalJSON(data []byte) error {
	type unmarshaler StrReplaceEditorResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StrReplaceEditorResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StrReplaceEditorResult) MarshalJSON() ([]byte, error) {
	type embed StrReplaceEditorResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StrReplaceEditorResult) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.
type Command string

const (
	CommandView       Command = "view"
	CommandCreate     Command = "create"
	CommandStrReplace Command = "str_replace"
	CommandInsert     Command = "insert"
	CommandUndoEdit   Command = "undo_edit"
)

func NewCommandFromString(s string) (Command, error) {
	switch s {
	case "view":
		return CommandView, nil
	case "create":
		return CommandCreate, nil
	case "str_replace":
		return CommandStrReplace, nil
	case "insert":
		return CommandInsert, nil
	case "undo_edit":
		return CommandUndoEdit, nil
	}
	var t Command
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Command) Ptr() *Command {
	return &c
}

type StrReplaceEditorRequestReplaceMode string

const (
	StrReplaceEditorRequestReplaceModeAll   StrReplaceEditorRequestReplaceMode = "ALL"
	StrReplaceEditorRequestReplaceModeFirst StrReplaceEditorRequestReplaceMode = "FIRST"
	StrReplaceEditorRequestReplaceModeLast  StrReplaceEditorRequestReplaceMode = "LAST"
)

func NewStrReplaceEditorRequestReplaceModeFromString(s string) (StrReplaceEditorRequestReplaceMode, error) {
	switch s {
	case "ALL":
		return StrReplaceEditorRequestReplaceModeAll, nil
	case "FIRST":
		return StrReplaceEditorRequestReplaceModeFirst, nil
	case "LAST":
		return StrReplaceEditorRequestReplaceModeLast, nil
	}
	var t StrReplaceEditorRequestReplaceMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StrReplaceEditorRequestReplaceMode) Ptr() *StrReplaceEditorRequestReplaceMode {
	return &s
}

type BodyUploadFile struct {
	File io.Reader `json:"-" url:"-"`
	Path *string   `json:"path,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyUploadFile) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

var (
	fileWriteRequestFieldFile            = big.NewInt(1 << 0)
	fileWriteRequestFieldContent         = big.NewInt(1 << 1)
	fileWriteRequestFieldEncoding        = big.NewInt(1 << 2)
	fileWriteRequestFieldAppend          = big.NewInt(1 << 3)
	fileWriteRequestFieldLeadingNewline  = big.NewInt(1 << 4)
	fileWriteRequestFieldTrailingNewline = big.NewInt(1 << 5)
	fileWriteRequestFieldSudo            = big.NewInt(1 << 6)
)

type FileWriteRequest struct {
	// Absolute file path
	File string `json:"file" url:"-"`
	// Content to write (text or base64 encoded for binary)
	Content string `json:"content" url:"-"`
	// Content encoding: utf-8 for text, base64 for binary data
	Encoding *FileContentEncoding `json:"encoding,omitempty" url:"-"`
	// Whether to use append mode
	Append *bool `json:"append,omitempty" url:"-"`
	// Whether to add leading newline (only for text mode)
	LeadingNewline *bool `json:"leading_newline,omitempty" url:"-"`
	// Whether to add trailing newline (only for text mode)
	TrailingNewline *bool `json:"trailing_newline,omitempty" url:"-"`
	// Whether to use sudo privileges
	Sudo *bool `json:"sudo,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FileWriteRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFile sets the File field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteRequest) SetFile(file string) {
	f.File = file
	f.require(fileWriteRequestFieldFile)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteRequest) SetContent(content string) {
	f.Content = content
	f.require(fileWriteRequestFieldContent)
}

// SetEncoding sets the Encoding field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteRequest) SetEncoding(encoding *FileContentEncoding) {
	f.Encoding = encoding
	f.require(fileWriteRequestFieldEncoding)
}

// SetAppend sets the Append field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteRequest) SetAppend(append *bool) {
	f.Append = append
	f.require(fileWriteRequestFieldAppend)
}

// SetLeadingNewline sets the LeadingNewline field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteRequest) SetLeadingNewline(leadingNewline *bool) {
	f.LeadingNewline = leadingNewline
	f.require(fileWriteRequestFieldLeadingNewline)
}

// SetTrailingNewline sets the TrailingNewline field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteRequest) SetTrailingNewline(trailingNewline *bool) {
	f.TrailingNewline = trailingNewline
	f.require(fileWriteRequestFieldTrailingNewline)
}

// SetSudo sets the Sudo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FileWriteRequest) SetSudo(sudo *bool) {
	f.Sudo = sudo
	f.require(fileWriteRequestFieldSudo)
}
