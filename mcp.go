// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
	big "math/big"
)

var (
	annotationsFieldAudience = big.NewInt(1 << 0)
	annotationsFieldPriority = big.NewInt(1 << 1)
)

type Annotations struct {
	Audience []AnnotationsAudienceItem `json:"audience,omitempty" url:"audience,omitempty"`
	Priority *float64                  `json:"priority,omitempty" url:"priority,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (a *Annotations) GetAudience() []AnnotationsAudienceItem {
	if a == nil {
		return nil
	}
	return a.Audience
}

func (a *Annotations) GetPriority() *float64 {
	if a == nil {
		return nil
	}
	return a.Priority
}

func (a *Annotations) GetExtraProperties() map[string]interface{} {
	return a.ExtraProperties
}

func (a *Annotations) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAudience sets the Audience field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Annotations) SetAudience(audience []AnnotationsAudienceItem) {
	a.Audience = audience
	a.require(annotationsFieldAudience)
}

// SetPriority sets the Priority field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Annotations) SetPriority(priority *float64) {
	a.Priority = priority
	a.require(annotationsFieldPriority)
}

func (a *Annotations) UnmarshalJSON(data []byte) error {
	type embed Annotations
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Annotations(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.ExtraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Annotations) MarshalJSON() ([]byte, error) {
	type embed Annotations
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, a.ExtraProperties)
}

func (a *Annotations) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AnnotationsAudienceItem string

const (
	AnnotationsAudienceItemUser      AnnotationsAudienceItem = "user"
	AnnotationsAudienceItemAssistant AnnotationsAudienceItem = "assistant"
)

func NewAnnotationsAudienceItemFromString(s string) (AnnotationsAudienceItem, error) {
	switch s {
	case "user":
		return AnnotationsAudienceItemUser, nil
	case "assistant":
		return AnnotationsAudienceItemAssistant, nil
	}
	var t AnnotationsAudienceItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AnnotationsAudienceItem) Ptr() *AnnotationsAudienceItem {
	return &a
}

// Audio content for a message.
var (
	audioContentFieldData        = big.NewInt(1 << 0)
	audioContentFieldMimeType    = big.NewInt(1 << 1)
	audioContentFieldAnnotations = big.NewInt(1 << 2)
	audioContentFieldMeta        = big.NewInt(1 << 3)
)

type AudioContent struct {
	Data        string                 `json:"data" url:"data"`
	MimeType    string                 `json:"mimeType" url:"mimeType"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (a *AudioContent) GetData() string {
	if a == nil {
		return ""
	}
	return a.Data
}

func (a *AudioContent) GetMimeType() string {
	if a == nil {
		return ""
	}
	return a.MimeType
}

func (a *AudioContent) GetAnnotations() *Annotations {
	if a == nil {
		return nil
	}
	return a.Annotations
}

func (a *AudioContent) GetMeta() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Meta
}

func (a *AudioContent) GetExtraProperties() map[string]interface{} {
	return a.ExtraProperties
}

func (a *AudioContent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudioContent) SetData(data string) {
	a.Data = data
	a.require(audioContentFieldData)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudioContent) SetMimeType(mimeType string) {
	a.MimeType = mimeType
	a.require(audioContentFieldMimeType)
}

// SetAnnotations sets the Annotations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudioContent) SetAnnotations(annotations *Annotations) {
	a.Annotations = annotations
	a.require(audioContentFieldAnnotations)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AudioContent) SetMeta(meta map[string]interface{}) {
	a.Meta = meta
	a.require(audioContentFieldMeta)
}

func (a *AudioContent) UnmarshalJSON(data []byte) error {
	type embed AudioContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AudioContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.ExtraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AudioContent) MarshalJSON() ([]byte, error) {
	type embed AudioContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, a.ExtraProperties)
}

func (a *AudioContent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Binary contents of a resource.
var (
	blobResourceContentsFieldUri      = big.NewInt(1 << 0)
	blobResourceContentsFieldMimeType = big.NewInt(1 << 1)
	blobResourceContentsFieldMeta     = big.NewInt(1 << 2)
	blobResourceContentsFieldBlob     = big.NewInt(1 << 3)
)

type BlobResourceContents struct {
	Uri      string                 `json:"uri" url:"uri"`
	MimeType *string                `json:"mimeType,omitempty" url:"mimeType,omitempty"`
	Meta     map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`
	Blob     string                 `json:"blob" url:"blob"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (b *BlobResourceContents) GetUri() string {
	if b == nil {
		return ""
	}
	return b.Uri
}

func (b *BlobResourceContents) GetMimeType() *string {
	if b == nil {
		return nil
	}
	return b.MimeType
}

func (b *BlobResourceContents) GetMeta() map[string]interface{} {
	if b == nil {
		return nil
	}
	return b.Meta
}

func (b *BlobResourceContents) GetBlob() string {
	if b == nil {
		return ""
	}
	return b.Blob
}

func (b *BlobResourceContents) GetExtraProperties() map[string]interface{} {
	return b.ExtraProperties
}

func (b *BlobResourceContents) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUri sets the Uri field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BlobResourceContents) SetUri(uri string) {
	b.Uri = uri
	b.require(blobResourceContentsFieldUri)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BlobResourceContents) SetMimeType(mimeType *string) {
	b.MimeType = mimeType
	b.require(blobResourceContentsFieldMimeType)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BlobResourceContents) SetMeta(meta map[string]interface{}) {
	b.Meta = meta
	b.require(blobResourceContentsFieldMeta)
}

// SetBlob sets the Blob field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BlobResourceContents) SetBlob(blob string) {
	b.Blob = blob
	b.require(blobResourceContentsFieldBlob)
}

func (b *BlobResourceContents) UnmarshalJSON(data []byte) error {
	type embed BlobResourceContents
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BlobResourceContents(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.ExtraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BlobResourceContents) MarshalJSON() ([]byte, error) {
	type embed BlobResourceContents
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, b.ExtraProperties)
}

func (b *BlobResourceContents) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The server's response to a tool call.
var (
	callToolResultFieldMeta              = big.NewInt(1 << 0)
	callToolResultFieldContent           = big.NewInt(1 << 1)
	callToolResultFieldStructuredContent = big.NewInt(1 << 2)
	callToolResultFieldIsError           = big.NewInt(1 << 3)
)

type CallToolResult struct {
	Meta              map[string]interface{}                        `json:"_meta,omitempty" url:"_meta,omitempty"`
	Content           []*ResponseCallToolResultModelDataContentItem `json:"content" url:"content"`
	StructuredContent map[string]interface{}                        `json:"structuredContent,omitempty" url:"structuredContent,omitempty"`
	IsError           *bool                                         `json:"isError,omitempty" url:"isError,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (c *CallToolResult) GetMeta() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Meta
}

func (c *CallToolResult) GetContent() []*ResponseCallToolResultModelDataContentItem {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *CallToolResult) GetStructuredContent() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.StructuredContent
}

func (c *CallToolResult) GetIsError() *bool {
	if c == nil {
		return nil
	}
	return c.IsError
}

func (c *CallToolResult) GetExtraProperties() map[string]interface{} {
	return c.ExtraProperties
}

func (c *CallToolResult) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CallToolResult) SetMeta(meta map[string]interface{}) {
	c.Meta = meta
	c.require(callToolResultFieldMeta)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CallToolResult) SetContent(content []*ResponseCallToolResultModelDataContentItem) {
	c.Content = content
	c.require(callToolResultFieldContent)
}

// SetStructuredContent sets the StructuredContent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CallToolResult) SetStructuredContent(structuredContent map[string]interface{}) {
	c.StructuredContent = structuredContent
	c.require(callToolResultFieldStructuredContent)
}

// SetIsError sets the IsError field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CallToolResult) SetIsError(isError *bool) {
	c.IsError = isError
	c.require(callToolResultFieldIsError)
}

func (c *CallToolResult) UnmarshalJSON(data []byte) error {
	type embed CallToolResult
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CallToolResult(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.ExtraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CallToolResult) MarshalJSON() ([]byte, error) {
	type embed CallToolResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, c.ExtraProperties)
}

func (c *CallToolResult) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The contents of a resource, embedded into a prompt or tool call result.
//
// It is up to the client how best to render embedded resources for the benefit
// of the LLM and/or the user.
var (
	embeddedResourceFieldResource    = big.NewInt(1 << 0)
	embeddedResourceFieldAnnotations = big.NewInt(1 << 1)
	embeddedResourceFieldMeta        = big.NewInt(1 << 2)
)

type EmbeddedResource struct {
	Resource    *Resource              `json:"resource" url:"resource"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (e *EmbeddedResource) GetResource() *Resource {
	if e == nil {
		return nil
	}
	return e.Resource
}

func (e *EmbeddedResource) GetAnnotations() *Annotations {
	if e == nil {
		return nil
	}
	return e.Annotations
}

func (e *EmbeddedResource) GetMeta() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Meta
}

func (e *EmbeddedResource) GetExtraProperties() map[string]interface{} {
	return e.ExtraProperties
}

func (e *EmbeddedResource) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetResource sets the Resource field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EmbeddedResource) SetResource(resource *Resource) {
	e.Resource = resource
	e.require(embeddedResourceFieldResource)
}

// SetAnnotations sets the Annotations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EmbeddedResource) SetAnnotations(annotations *Annotations) {
	e.Annotations = annotations
	e.require(embeddedResourceFieldAnnotations)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EmbeddedResource) SetMeta(meta map[string]interface{}) {
	e.Meta = meta
	e.require(embeddedResourceFieldMeta)
}

func (e *EmbeddedResource) UnmarshalJSON(data []byte) error {
	type embed EmbeddedResource
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmbeddedResource(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.ExtraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbeddedResource) MarshalJSON() ([]byte, error) {
	type embed EmbeddedResource
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, e.ExtraProperties)
}

func (e *EmbeddedResource) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// An icon for display in user interfaces.
var (
	iconFieldSrc      = big.NewInt(1 << 0)
	iconFieldMimeType = big.NewInt(1 << 1)
	iconFieldSizes    = big.NewInt(1 << 2)
)

type Icon struct {
	Src      string   `json:"src" url:"src"`
	MimeType *string  `json:"mimeType,omitempty" url:"mimeType,omitempty"`
	Sizes    []string `json:"sizes,omitempty" url:"sizes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (i *Icon) GetSrc() string {
	if i == nil {
		return ""
	}
	return i.Src
}

func (i *Icon) GetMimeType() *string {
	if i == nil {
		return nil
	}
	return i.MimeType
}

func (i *Icon) GetSizes() []string {
	if i == nil {
		return nil
	}
	return i.Sizes
}

func (i *Icon) GetExtraProperties() map[string]interface{} {
	return i.ExtraProperties
}

func (i *Icon) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetSrc sets the Src field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Icon) SetSrc(src string) {
	i.Src = src
	i.require(iconFieldSrc)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Icon) SetMimeType(mimeType *string) {
	i.MimeType = mimeType
	i.require(iconFieldMimeType)
}

// SetSizes sets the Sizes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Icon) SetSizes(sizes []string) {
	i.Sizes = sizes
	i.require(iconFieldSizes)
}

func (i *Icon) UnmarshalJSON(data []byte) error {
	type embed Icon
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Icon(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.ExtraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Icon) MarshalJSON() ([]byte, error) {
	type embed Icon
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, i.ExtraProperties)
}

func (i *Icon) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Image content for a message.
var (
	imageContentFieldData        = big.NewInt(1 << 0)
	imageContentFieldMimeType    = big.NewInt(1 << 1)
	imageContentFieldAnnotations = big.NewInt(1 << 2)
	imageContentFieldMeta        = big.NewInt(1 << 3)
)

type ImageContent struct {
	Data        string                 `json:"data" url:"data"`
	MimeType    string                 `json:"mimeType" url:"mimeType"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (i *ImageContent) GetData() string {
	if i == nil {
		return ""
	}
	return i.Data
}

func (i *ImageContent) GetMimeType() string {
	if i == nil {
		return ""
	}
	return i.MimeType
}

func (i *ImageContent) GetAnnotations() *Annotations {
	if i == nil {
		return nil
	}
	return i.Annotations
}

func (i *ImageContent) GetMeta() map[string]interface{} {
	if i == nil {
		return nil
	}
	return i.Meta
}

func (i *ImageContent) GetExtraProperties() map[string]interface{} {
	return i.ExtraProperties
}

func (i *ImageContent) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageContent) SetData(data string) {
	i.Data = data
	i.require(imageContentFieldData)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageContent) SetMimeType(mimeType string) {
	i.MimeType = mimeType
	i.require(imageContentFieldMimeType)
}

// SetAnnotations sets the Annotations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageContent) SetAnnotations(annotations *Annotations) {
	i.Annotations = annotations
	i.require(imageContentFieldAnnotations)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageContent) SetMeta(meta map[string]interface{}) {
	i.Meta = meta
	i.require(imageContentFieldMeta)
}

func (i *ImageContent) UnmarshalJSON(data []byte) error {
	type embed ImageContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = ImageContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.ExtraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImageContent) MarshalJSON() ([]byte, error) {
	type embed ImageContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, i.ExtraProperties)
}

func (i *ImageContent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The server's response to a tools/list request from the client.
var (
	listToolsResultFieldMeta       = big.NewInt(1 << 0)
	listToolsResultFieldNextCursor = big.NewInt(1 << 1)
	listToolsResultFieldTools      = big.NewInt(1 << 2)
)

type ListToolsResult struct {
	Meta       map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`
	NextCursor *string                `json:"nextCursor,omitempty" url:"nextCursor,omitempty"`
	Tools      []*Tool                `json:"tools" url:"tools"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (l *ListToolsResult) GetMeta() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.Meta
}

func (l *ListToolsResult) GetNextCursor() *string {
	if l == nil {
		return nil
	}
	return l.NextCursor
}

func (l *ListToolsResult) GetTools() []*Tool {
	if l == nil {
		return nil
	}
	return l.Tools
}

func (l *ListToolsResult) GetExtraProperties() map[string]interface{} {
	return l.ExtraProperties
}

func (l *ListToolsResult) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsResult) SetMeta(meta map[string]interface{}) {
	l.Meta = meta
	l.require(listToolsResultFieldMeta)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsResult) SetNextCursor(nextCursor *string) {
	l.NextCursor = nextCursor
	l.require(listToolsResultFieldNextCursor)
}

// SetTools sets the Tools field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListToolsResult) SetTools(tools []*Tool) {
	l.Tools = tools
	l.require(listToolsResultFieldTools)
}

func (l *ListToolsResult) UnmarshalJSON(data []byte) error {
	type embed ListToolsResult
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = ListToolsResult(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.ExtraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListToolsResult) MarshalJSON() ([]byte, error) {
	type embed ListToolsResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, l.ExtraProperties)
}

func (l *ListToolsResult) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Resource struct {
	TextResourceContents *TextResourceContents
	BlobResourceContents *BlobResourceContents

	typ string
}

func (r *Resource) GetTextResourceContents() *TextResourceContents {
	if r == nil {
		return nil
	}
	return r.TextResourceContents
}

func (r *Resource) GetBlobResourceContents() *BlobResourceContents {
	if r == nil {
		return nil
	}
	return r.BlobResourceContents
}

func (r *Resource) UnmarshalJSON(data []byte) error {
	valueTextResourceContents := new(TextResourceContents)
	if err := json.Unmarshal(data, &valueTextResourceContents); err == nil {
		r.typ = "TextResourceContents"
		r.TextResourceContents = valueTextResourceContents
		return nil
	}
	valueBlobResourceContents := new(BlobResourceContents)
	if err := json.Unmarshal(data, &valueBlobResourceContents); err == nil {
		r.typ = "BlobResourceContents"
		r.BlobResourceContents = valueBlobResourceContents
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Resource) MarshalJSON() ([]byte, error) {
	if r.typ == "TextResourceContents" || r.TextResourceContents != nil {
		return json.Marshal(r.TextResourceContents)
	}
	if r.typ == "BlobResourceContents" || r.BlobResourceContents != nil {
		return json.Marshal(r.BlobResourceContents)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type ResourceVisitor interface {
	VisitTextResourceContents(*TextResourceContents) error
	VisitBlobResourceContents(*BlobResourceContents) error
}

func (r *Resource) Accept(visitor ResourceVisitor) error {
	if r.typ == "TextResourceContents" || r.TextResourceContents != nil {
		return visitor.VisitTextResourceContents(r.TextResourceContents)
	}
	if r.typ == "BlobResourceContents" || r.BlobResourceContents != nil {
		return visitor.VisitBlobResourceContents(r.BlobResourceContents)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// A resource that the server is capable of reading, included in a prompt or tool call result.
//
// Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
var (
	resourceLinkFieldName        = big.NewInt(1 << 0)
	resourceLinkFieldTitle       = big.NewInt(1 << 1)
	resourceLinkFieldUri         = big.NewInt(1 << 2)
	resourceLinkFieldDescription = big.NewInt(1 << 3)
	resourceLinkFieldMimeType    = big.NewInt(1 << 4)
	resourceLinkFieldSize        = big.NewInt(1 << 5)
	resourceLinkFieldIcons       = big.NewInt(1 << 6)
	resourceLinkFieldAnnotations = big.NewInt(1 << 7)
	resourceLinkFieldMeta        = big.NewInt(1 << 8)
)

type ResourceLink struct {
	Name        string                 `json:"name" url:"name"`
	Title       *string                `json:"title,omitempty" url:"title,omitempty"`
	Uri         string                 `json:"uri" url:"uri"`
	Description *string                `json:"description,omitempty" url:"description,omitempty"`
	MimeType    *string                `json:"mimeType,omitempty" url:"mimeType,omitempty"`
	Size        *int                   `json:"size,omitempty" url:"size,omitempty"`
	Icons       []*Icon                `json:"icons,omitempty" url:"icons,omitempty"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (r *ResourceLink) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *ResourceLink) GetTitle() *string {
	if r == nil {
		return nil
	}
	return r.Title
}

func (r *ResourceLink) GetUri() string {
	if r == nil {
		return ""
	}
	return r.Uri
}

func (r *ResourceLink) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *ResourceLink) GetMimeType() *string {
	if r == nil {
		return nil
	}
	return r.MimeType
}

func (r *ResourceLink) GetSize() *int {
	if r == nil {
		return nil
	}
	return r.Size
}

func (r *ResourceLink) GetIcons() []*Icon {
	if r == nil {
		return nil
	}
	return r.Icons
}

func (r *ResourceLink) GetAnnotations() *Annotations {
	if r == nil {
		return nil
	}
	return r.Annotations
}

func (r *ResourceLink) GetMeta() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Meta
}

func (r *ResourceLink) GetExtraProperties() map[string]interface{} {
	return r.ExtraProperties
}

func (r *ResourceLink) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetName(name string) {
	r.Name = name
	r.require(resourceLinkFieldName)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetTitle(title *string) {
	r.Title = title
	r.require(resourceLinkFieldTitle)
}

// SetUri sets the Uri field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetUri(uri string) {
	r.Uri = uri
	r.require(resourceLinkFieldUri)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetDescription(description *string) {
	r.Description = description
	r.require(resourceLinkFieldDescription)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetMimeType(mimeType *string) {
	r.MimeType = mimeType
	r.require(resourceLinkFieldMimeType)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetSize(size *int) {
	r.Size = size
	r.require(resourceLinkFieldSize)
}

// SetIcons sets the Icons field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetIcons(icons []*Icon) {
	r.Icons = icons
	r.require(resourceLinkFieldIcons)
}

// SetAnnotations sets the Annotations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetAnnotations(annotations *Annotations) {
	r.Annotations = annotations
	r.require(resourceLinkFieldAnnotations)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResourceLink) SetMeta(meta map[string]interface{}) {
	r.Meta = meta
	r.require(resourceLinkFieldMeta)
}

func (r *ResourceLink) UnmarshalJSON(data []byte) error {
	type embed ResourceLink
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = ResourceLink(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.ExtraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceLink) MarshalJSON() ([]byte, error) {
	type embed ResourceLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, r.ExtraProperties)
}

func (r *ResourceLink) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseCallToolResultModelFieldSuccess = big.NewInt(1 << 0)
	responseCallToolResultModelFieldMessage = big.NewInt(1 << 1)
	responseCallToolResultModelFieldData    = big.NewInt(1 << 2)
)

type ResponseCallToolResultModel struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *CallToolResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseCallToolResultModel) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseCallToolResultModel) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseCallToolResultModel) GetData() *CallToolResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseCallToolResultModel) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseCallToolResultModel) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCallToolResultModel) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseCallToolResultModelFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCallToolResultModel) SetMessage(message *string) {
	r.Message = message
	r.require(responseCallToolResultModelFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCallToolResultModel) SetData(data *CallToolResult) {
	r.Data = data
	r.require(responseCallToolResultModelFieldData)
}

func (r *ResponseCallToolResultModel) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseCallToolResultModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseCallToolResultModel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseCallToolResultModel) MarshalJSON() ([]byte, error) {
	type embed ResponseCallToolResultModel
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseCallToolResultModel) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseCallToolResultModelDataContentItem struct {
	Type         string
	Text         *TextContent
	Image        *ImageContent
	Audio        *AudioContent
	ResourceLink *ResourceLink
	Resource     *EmbeddedResource
}

func (r *ResponseCallToolResultModelDataContentItem) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseCallToolResultModelDataContentItem) GetText() *TextContent {
	if r == nil {
		return nil
	}
	return r.Text
}

func (r *ResponseCallToolResultModelDataContentItem) GetImage() *ImageContent {
	if r == nil {
		return nil
	}
	return r.Image
}

func (r *ResponseCallToolResultModelDataContentItem) GetAudio() *AudioContent {
	if r == nil {
		return nil
	}
	return r.Audio
}

func (r *ResponseCallToolResultModelDataContentItem) GetResourceLink() *ResourceLink {
	if r == nil {
		return nil
	}
	return r.ResourceLink
}

func (r *ResponseCallToolResultModelDataContentItem) GetResource() *EmbeddedResource {
	if r == nil {
		return nil
	}
	return r.Resource
}

func (r *ResponseCallToolResultModelDataContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(TextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Text = value
	case "image":
		value := new(ImageContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Image = value
	case "audio":
		value := new(AudioContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Audio = value
	case "resource_link":
		value := new(ResourceLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.ResourceLink = value
	case "resource":
		value := new(EmbeddedResource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Resource = value
	}
	return nil
}

func (r ResponseCallToolResultModelDataContentItem) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Text != nil {
		return internal.MarshalJSONWithExtraProperty(r.Text, "type", "text")
	}
	if r.Image != nil {
		return internal.MarshalJSONWithExtraProperty(r.Image, "type", "image")
	}
	if r.Audio != nil {
		return internal.MarshalJSONWithExtraProperty(r.Audio, "type", "audio")
	}
	if r.ResourceLink != nil {
		return internal.MarshalJSONWithExtraProperty(r.ResourceLink, "type", "resource_link")
	}
	if r.Resource != nil {
		return internal.MarshalJSONWithExtraProperty(r.Resource, "type", "resource")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ResponseCallToolResultModelDataContentItemVisitor interface {
	VisitText(*TextContent) error
	VisitImage(*ImageContent) error
	VisitAudio(*AudioContent) error
	VisitResourceLink(*ResourceLink) error
	VisitResource(*EmbeddedResource) error
}

func (r *ResponseCallToolResultModelDataContentItem) Accept(visitor ResponseCallToolResultModelDataContentItemVisitor) error {
	if r.Text != nil {
		return visitor.VisitText(r.Text)
	}
	if r.Image != nil {
		return visitor.VisitImage(r.Image)
	}
	if r.Audio != nil {
		return visitor.VisitAudio(r.Audio)
	}
	if r.ResourceLink != nil {
		return visitor.VisitResourceLink(r.ResourceLink)
	}
	if r.Resource != nil {
		return visitor.VisitResource(r.Resource)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *ResponseCallToolResultModelDataContentItem) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Text != nil {
		fields = append(fields, "text")
	}
	if r.Image != nil {
		fields = append(fields, "image")
	}
	if r.Audio != nil {
		fields = append(fields, "audio")
	}
	if r.ResourceLink != nil {
		fields = append(fields, "resource_link")
	}
	if r.Resource != nil {
		fields = append(fields, "resource")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

var (
	responseListStrFieldSuccess = big.NewInt(1 << 0)
	responseListStrFieldMessage = big.NewInt(1 << 1)
	responseListStrFieldData    = big.NewInt(1 << 2)
)

type ResponseListStr struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data []string `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseListStr) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseListStr) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseListStr) GetData() []string {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseListStr) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseListStr) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseListStr) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseListStrFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseListStr) SetMessage(message *string) {
	r.Message = message
	r.require(responseListStrFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseListStr) SetData(data []string) {
	r.Data = data
	r.require(responseListStrFieldData)
}

func (r *ResponseListStr) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseListStr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseListStr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseListStr) MarshalJSON() ([]byte, error) {
	type embed ResponseListStr
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseListStr) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseListToolsResultModelFieldSuccess = big.NewInt(1 << 0)
	responseListToolsResultModelFieldMessage = big.NewInt(1 << 1)
	responseListToolsResultModelFieldData    = big.NewInt(1 << 2)
)

type ResponseListToolsResultModel struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *ListToolsResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseListToolsResultModel) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseListToolsResultModel) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseListToolsResultModel) GetData() *ListToolsResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseListToolsResultModel) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseListToolsResultModel) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseListToolsResultModel) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseListToolsResultModelFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseListToolsResultModel) SetMessage(message *string) {
	r.Message = message
	r.require(responseListToolsResultModelFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseListToolsResultModel) SetData(data *ListToolsResult) {
	r.Data = data
	r.require(responseListToolsResultModelFieldData)
}

func (r *ResponseListToolsResultModel) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseListToolsResultModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseListToolsResultModel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseListToolsResultModel) MarshalJSON() ([]byte, error) {
	type embed ResponseListToolsResultModel
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseListToolsResultModel) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Text content for a message.
var (
	textContentFieldText        = big.NewInt(1 << 0)
	textContentFieldAnnotations = big.NewInt(1 << 1)
	textContentFieldMeta        = big.NewInt(1 << 2)
)

type TextContent struct {
	Text        string                 `json:"text" url:"text"`
	Annotations *Annotations           `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta        map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *TextContent) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TextContent) GetAnnotations() *Annotations {
	if t == nil {
		return nil
	}
	return t.Annotations
}

func (t *TextContent) GetMeta() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Meta
}

func (t *TextContent) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *TextContent) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextContent) SetText(text string) {
	t.Text = text
	t.require(textContentFieldText)
}

// SetAnnotations sets the Annotations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextContent) SetAnnotations(annotations *Annotations) {
	t.Annotations = annotations
	t.require(textContentFieldAnnotations)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextContent) SetMeta(meta map[string]interface{}) {
	t.Meta = meta
	t.require(textContentFieldMeta)
}

func (t *TextContent) UnmarshalJSON(data []byte) error {
	type embed TextContent
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextContent(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextContent) MarshalJSON() ([]byte, error) {
	type embed TextContent
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, t.ExtraProperties)
}

func (t *TextContent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Text contents of a resource.
var (
	textResourceContentsFieldUri      = big.NewInt(1 << 0)
	textResourceContentsFieldMimeType = big.NewInt(1 << 1)
	textResourceContentsFieldMeta     = big.NewInt(1 << 2)
	textResourceContentsFieldText     = big.NewInt(1 << 3)
)

type TextResourceContents struct {
	Uri      string                 `json:"uri" url:"uri"`
	MimeType *string                `json:"mimeType,omitempty" url:"mimeType,omitempty"`
	Meta     map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`
	Text     string                 `json:"text" url:"text"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *TextResourceContents) GetUri() string {
	if t == nil {
		return ""
	}
	return t.Uri
}

func (t *TextResourceContents) GetMimeType() *string {
	if t == nil {
		return nil
	}
	return t.MimeType
}

func (t *TextResourceContents) GetMeta() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Meta
}

func (t *TextResourceContents) GetText() string {
	if t == nil {
		return ""
	}
	return t.Text
}

func (t *TextResourceContents) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *TextResourceContents) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetUri sets the Uri field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextResourceContents) SetUri(uri string) {
	t.Uri = uri
	t.require(textResourceContentsFieldUri)
}

// SetMimeType sets the MimeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextResourceContents) SetMimeType(mimeType *string) {
	t.MimeType = mimeType
	t.require(textResourceContentsFieldMimeType)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextResourceContents) SetMeta(meta map[string]interface{}) {
	t.Meta = meta
	t.require(textResourceContentsFieldMeta)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextResourceContents) SetText(text string) {
	t.Text = text
	t.require(textResourceContentsFieldText)
}

func (t *TextResourceContents) UnmarshalJSON(data []byte) error {
	type embed TextResourceContents
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TextResourceContents(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextResourceContents) MarshalJSON() ([]byte, error) {
	type embed TextResourceContents
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, t.ExtraProperties)
}

func (t *TextResourceContents) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Definition for a tool the client can call.
var (
	toolFieldName         = big.NewInt(1 << 0)
	toolFieldTitle        = big.NewInt(1 << 1)
	toolFieldDescription  = big.NewInt(1 << 2)
	toolFieldInputSchema  = big.NewInt(1 << 3)
	toolFieldOutputSchema = big.NewInt(1 << 4)
	toolFieldIcons        = big.NewInt(1 << 5)
	toolFieldAnnotations  = big.NewInt(1 << 6)
	toolFieldMeta         = big.NewInt(1 << 7)
	toolFieldExecution    = big.NewInt(1 << 8)
)

type Tool struct {
	Name         string                 `json:"name" url:"name"`
	Title        *string                `json:"title,omitempty" url:"title,omitempty"`
	Description  *string                `json:"description,omitempty" url:"description,omitempty"`
	InputSchema  map[string]interface{} `json:"inputSchema" url:"inputSchema"`
	OutputSchema map[string]interface{} `json:"outputSchema,omitempty" url:"outputSchema,omitempty"`
	Icons        []*Icon                `json:"icons,omitempty" url:"icons,omitempty"`
	Annotations  *ToolAnnotations       `json:"annotations,omitempty" url:"annotations,omitempty"`
	Meta         map[string]interface{} `json:"_meta,omitempty" url:"_meta,omitempty"`
	Execution    *ToolExecution         `json:"execution,omitempty" url:"execution,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *Tool) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *Tool) GetTitle() *string {
	if t == nil {
		return nil
	}
	return t.Title
}

func (t *Tool) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *Tool) GetInputSchema() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.InputSchema
}

func (t *Tool) GetOutputSchema() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.OutputSchema
}

func (t *Tool) GetIcons() []*Icon {
	if t == nil {
		return nil
	}
	return t.Icons
}

func (t *Tool) GetAnnotations() *ToolAnnotations {
	if t == nil {
		return nil
	}
	return t.Annotations
}

func (t *Tool) GetMeta() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Meta
}

func (t *Tool) GetExecution() *ToolExecution {
	if t == nil {
		return nil
	}
	return t.Execution
}

func (t *Tool) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *Tool) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetName(name string) {
	t.Name = name
	t.require(toolFieldName)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetTitle(title *string) {
	t.Title = title
	t.require(toolFieldTitle)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetDescription(description *string) {
	t.Description = description
	t.require(toolFieldDescription)
}

// SetInputSchema sets the InputSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetInputSchema(inputSchema map[string]interface{}) {
	t.InputSchema = inputSchema
	t.require(toolFieldInputSchema)
}

// SetOutputSchema sets the OutputSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetOutputSchema(outputSchema map[string]interface{}) {
	t.OutputSchema = outputSchema
	t.require(toolFieldOutputSchema)
}

// SetIcons sets the Icons field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetIcons(icons []*Icon) {
	t.Icons = icons
	t.require(toolFieldIcons)
}

// SetAnnotations sets the Annotations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetAnnotations(annotations *ToolAnnotations) {
	t.Annotations = annotations
	t.require(toolFieldAnnotations)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetMeta(meta map[string]interface{}) {
	t.Meta = meta
	t.require(toolFieldMeta)
}

// SetExecution sets the Execution field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tool) SetExecution(execution *ToolExecution) {
	t.Execution = execution
	t.require(toolFieldExecution)
}

func (t *Tool) UnmarshalJSON(data []byte) error {
	type embed Tool
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Tool(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tool) MarshalJSON() ([]byte, error) {
	type embed Tool
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, t.ExtraProperties)
}

func (t *Tool) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Additional properties describing a Tool to clients.
//
// NOTE: all properties in ToolAnnotations are **hints**.
// They are not guaranteed to provide a faithful description of
// tool behavior (including descriptive properties like `title`).
//
// Clients should never make tool use decisions based on ToolAnnotations
// received from untrusted servers.
var (
	toolAnnotationsFieldTitle           = big.NewInt(1 << 0)
	toolAnnotationsFieldReadOnlyHint    = big.NewInt(1 << 1)
	toolAnnotationsFieldDestructiveHint = big.NewInt(1 << 2)
	toolAnnotationsFieldIdempotentHint  = big.NewInt(1 << 3)
	toolAnnotationsFieldOpenWorldHint   = big.NewInt(1 << 4)
)

type ToolAnnotations struct {
	Title           *string `json:"title,omitempty" url:"title,omitempty"`
	ReadOnlyHint    *bool   `json:"readOnlyHint,omitempty" url:"readOnlyHint,omitempty"`
	DestructiveHint *bool   `json:"destructiveHint,omitempty" url:"destructiveHint,omitempty"`
	IdempotentHint  *bool   `json:"idempotentHint,omitempty" url:"idempotentHint,omitempty"`
	OpenWorldHint   *bool   `json:"openWorldHint,omitempty" url:"openWorldHint,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *ToolAnnotations) GetTitle() *string {
	if t == nil {
		return nil
	}
	return t.Title
}

func (t *ToolAnnotations) GetReadOnlyHint() *bool {
	if t == nil {
		return nil
	}
	return t.ReadOnlyHint
}

func (t *ToolAnnotations) GetDestructiveHint() *bool {
	if t == nil {
		return nil
	}
	return t.DestructiveHint
}

func (t *ToolAnnotations) GetIdempotentHint() *bool {
	if t == nil {
		return nil
	}
	return t.IdempotentHint
}

func (t *ToolAnnotations) GetOpenWorldHint() *bool {
	if t == nil {
		return nil
	}
	return t.OpenWorldHint
}

func (t *ToolAnnotations) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *ToolAnnotations) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ToolAnnotations) SetTitle(title *string) {
	t.Title = title
	t.require(toolAnnotationsFieldTitle)
}

// SetReadOnlyHint sets the ReadOnlyHint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ToolAnnotations) SetReadOnlyHint(readOnlyHint *bool) {
	t.ReadOnlyHint = readOnlyHint
	t.require(toolAnnotationsFieldReadOnlyHint)
}

// SetDestructiveHint sets the DestructiveHint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ToolAnnotations) SetDestructiveHint(destructiveHint *bool) {
	t.DestructiveHint = destructiveHint
	t.require(toolAnnotationsFieldDestructiveHint)
}

// SetIdempotentHint sets the IdempotentHint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ToolAnnotations) SetIdempotentHint(idempotentHint *bool) {
	t.IdempotentHint = idempotentHint
	t.require(toolAnnotationsFieldIdempotentHint)
}

// SetOpenWorldHint sets the OpenWorldHint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ToolAnnotations) SetOpenWorldHint(openWorldHint *bool) {
	t.OpenWorldHint = openWorldHint
	t.require(toolAnnotationsFieldOpenWorldHint)
}

func (t *ToolAnnotations) UnmarshalJSON(data []byte) error {
	type embed ToolAnnotations
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolAnnotations(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolAnnotations) MarshalJSON() ([]byte, error) {
	type embed ToolAnnotations
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, t.ExtraProperties)
}

func (t *ToolAnnotations) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Execution-related properties for a tool.
var (
	toolExecutionFieldTaskSupport = big.NewInt(1 << 0)
)

type ToolExecution struct {
	TaskSupport *ToolExecutionTaskSupport `json:"taskSupport,omitempty" url:"taskSupport,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (t *ToolExecution) GetTaskSupport() *ToolExecutionTaskSupport {
	if t == nil {
		return nil
	}
	return t.TaskSupport
}

func (t *ToolExecution) GetExtraProperties() map[string]interface{} {
	return t.ExtraProperties
}

func (t *ToolExecution) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTaskSupport sets the TaskSupport field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ToolExecution) SetTaskSupport(taskSupport *ToolExecutionTaskSupport) {
	t.TaskSupport = taskSupport
	t.require(toolExecutionFieldTaskSupport)
}

func (t *ToolExecution) UnmarshalJSON(data []byte) error {
	type embed ToolExecution
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = ToolExecution(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.ExtraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolExecution) MarshalJSON() ([]byte, error) {
	type embed ToolExecution
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return internal.MarshalJSONWithExtraProperties(explicitMarshaler, t.ExtraProperties)
}

func (t *ToolExecution) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolExecutionTaskSupport string

const (
	ToolExecutionTaskSupportForbidden ToolExecutionTaskSupport = "forbidden"
	ToolExecutionTaskSupportOptional  ToolExecutionTaskSupport = "optional"
	ToolExecutionTaskSupportRequired  ToolExecutionTaskSupport = "required"
)

func NewToolExecutionTaskSupportFromString(s string) (ToolExecutionTaskSupport, error) {
	switch s {
	case "forbidden":
		return ToolExecutionTaskSupportForbidden, nil
	case "optional":
		return ToolExecutionTaskSupportOptional, nil
	case "required":
		return ToolExecutionTaskSupportRequired, nil
	}
	var t ToolExecutionTaskSupport
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t ToolExecutionTaskSupport) Ptr() *ToolExecutionTaskSupport {
	return &t
}
