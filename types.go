// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
	big "math/big"
)

var (
	httpValidationErrorFieldDetail = big.NewInt(1 << 0)
)

type HttpValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty" url:"detail,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HttpValidationError) GetDetail() []*ValidationError {
	if h == nil {
		return nil
	}
	return h.Detail
}

func (h *HttpValidationError) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpValidationError) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HttpValidationError) SetDetail(detail []*ValidationError) {
	h.Detail = detail
	h.require(httpValidationErrorFieldDetail)
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpValidationError) MarshalJSON() ([]byte, error) {
	type embed HttpValidationError
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HttpValidationError) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Generic response model for API interface return results
var (
	responseFieldSuccess = big.NewInt(1 << 0)
	responseFieldMessage = big.NewInt(1 << 1)
	responseFieldData    = big.NewInt(1 << 2)
)

type Response struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Response) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *Response) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *Response) GetData() interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *Response) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Response) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Response) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Response) SetMessage(message *string) {
	r.Message = message
	r.require(responseFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Response) SetData(data interface{}) {
	r.Data = data
	r.require(responseFieldData)
}

func (r *Response) UnmarshalJSON(data []byte) error {
	type unmarshaler Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Response(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Response) MarshalJSON() ([]byte, error) {
	type embed Response
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *Response) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	validationErrorFieldLoc  = big.NewInt(1 << 0)
	validationErrorFieldMsg  = big.NewInt(1 << 1)
	validationErrorFieldType = big.NewInt(1 << 2)
)

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc" url:"loc"`
	Msg  string                    `json:"msg" url:"msg"`
	Type string                    `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValidationError) GetLoc() []*ValidationErrorLocItem {
	if v == nil {
		return nil
	}
	return v.Loc
}

func (v *ValidationError) GetMsg() string {
	if v == nil {
		return ""
	}
	return v.Msg
}

func (v *ValidationError) GetType() string {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *ValidationError) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationError) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetLoc sets the Loc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValidationError) SetLoc(loc []*ValidationErrorLocItem) {
	v.Loc = loc
	v.require(validationErrorFieldLoc)
}

// SetMsg sets the Msg field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValidationError) SetMsg(msg string) {
	v.Msg = msg
	v.require(validationErrorFieldMsg)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValidationError) SetType(type_ string) {
	v.Type = type_
	v.require(validationErrorFieldType)
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) MarshalJSON() ([]byte, error) {
	type embed ValidationError
	var marshaler = struct {
		embed
	}{
		embed: embed(*v),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, v.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (v *ValidationError) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	String  string
	Integer int

	typ string
}

func (v *ValidationErrorLocItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *ValidationErrorLocItem) GetInteger() int {
	if v == nil {
		return 0
	}
	return v.Integer
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.typ = "Integer"
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Integer" || v.Integer != 0 {
		return json.Marshal(v.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Integer" || v.Integer != 0 {
		return visitor.VisitInteger(v.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}
