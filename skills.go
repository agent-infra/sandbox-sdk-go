// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
	io "io"
	big "math/big"
)

var (
	skillsListMetadataRequestFieldNames = big.NewInt(1 << 0)
)

type SkillsListMetadataRequest struct {
	Names *string `json:"-" url:"names,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SkillsListMetadataRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetNames sets the Names field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillsListMetadataRequest) SetNames(names *string) {
	s.Names = names
	s.require(skillsListMetadataRequestFieldNames)
}

type BodyRegisterSkills struct {
	File io.Reader `json:"-" url:"-"`
	Path *string   `json:"path,omitempty" url:"-"`
	Name *string   `json:"name,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyRegisterSkills) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

var (
	dependencyCommandResultFieldCommand = big.NewInt(1 << 0)
	dependencyCommandResultFieldSuccess = big.NewInt(1 << 1)
	dependencyCommandResultFieldStdout  = big.NewInt(1 << 2)
	dependencyCommandResultFieldStderr  = big.NewInt(1 << 3)
)

type DependencyCommandResult struct {
	// Executed dependency command
	Command []string `json:"command" url:"command"`
	// Whether the command succeeded
	Success bool `json:"success" url:"success"`
	// Standard output from command
	Stdout *string `json:"stdout,omitempty" url:"stdout,omitempty"`
	// Standard error from command
	Stderr *string `json:"stderr,omitempty" url:"stderr,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DependencyCommandResult) GetCommand() []string {
	if d == nil {
		return nil
	}
	return d.Command
}

func (d *DependencyCommandResult) GetSuccess() bool {
	if d == nil {
		return false
	}
	return d.Success
}

func (d *DependencyCommandResult) GetStdout() *string {
	if d == nil {
		return nil
	}
	return d.Stdout
}

func (d *DependencyCommandResult) GetStderr() *string {
	if d == nil {
		return nil
	}
	return d.Stderr
}

func (d *DependencyCommandResult) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DependencyCommandResult) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetCommand sets the Command field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DependencyCommandResult) SetCommand(command []string) {
	d.Command = command
	d.require(dependencyCommandResultFieldCommand)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DependencyCommandResult) SetSuccess(success bool) {
	d.Success = success
	d.require(dependencyCommandResultFieldSuccess)
}

// SetStdout sets the Stdout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DependencyCommandResult) SetStdout(stdout *string) {
	d.Stdout = stdout
	d.require(dependencyCommandResultFieldStdout)
}

// SetStderr sets the Stderr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DependencyCommandResult) SetStderr(stderr *string) {
	d.Stderr = stderr
	d.require(dependencyCommandResultFieldStderr)
}

func (d *DependencyCommandResult) UnmarshalJSON(data []byte) error {
	type unmarshaler DependencyCommandResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DependencyCommandResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DependencyCommandResult) MarshalJSON() ([]byte, error) {
	type embed DependencyCommandResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DependencyCommandResult) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	responseDictFieldSuccess = big.NewInt(1 << 0)
	responseDictFieldMessage = big.NewInt(1 << 1)
	responseDictFieldData    = big.NewInt(1 << 2)
)

type ResponseDict struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseDict) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseDict) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseDict) GetData() map[string]interface{} {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseDict) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseDict) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseDict) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseDictFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseDict) SetMessage(message *string) {
	r.Message = message
	r.require(responseDictFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseDict) SetData(data map[string]interface{}) {
	r.Data = data
	r.require(responseDictFieldData)
}

func (r *ResponseDict) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseDict
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseDict(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseDict) MarshalJSON() ([]byte, error) {
	type embed ResponseDict
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseDict) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseSkillContentResultFieldSuccess = big.NewInt(1 << 0)
	responseSkillContentResultFieldMessage = big.NewInt(1 << 1)
	responseSkillContentResultFieldData    = big.NewInt(1 << 2)
)

type ResponseSkillContentResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *SkillContentResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseSkillContentResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseSkillContentResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseSkillContentResult) GetData() *SkillContentResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseSkillContentResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseSkillContentResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillContentResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseSkillContentResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillContentResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseSkillContentResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillContentResult) SetData(data *SkillContentResult) {
	r.Data = data
	r.require(responseSkillContentResultFieldData)
}

func (r *ResponseSkillContentResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseSkillContentResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseSkillContentResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseSkillContentResult) MarshalJSON() ([]byte, error) {
	type embed ResponseSkillContentResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseSkillContentResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseSkillMetadataFieldSuccess = big.NewInt(1 << 0)
	responseSkillMetadataFieldMessage = big.NewInt(1 << 1)
	responseSkillMetadataFieldData    = big.NewInt(1 << 2)
)

type ResponseSkillMetadata struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *SkillMetadata `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseSkillMetadata) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseSkillMetadata) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseSkillMetadata) GetData() *SkillMetadata {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseSkillMetadata) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseSkillMetadata) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillMetadata) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseSkillMetadataFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillMetadata) SetMessage(message *string) {
	r.Message = message
	r.require(responseSkillMetadataFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillMetadata) SetData(data *SkillMetadata) {
	r.Data = data
	r.require(responseSkillMetadataFieldData)
}

func (r *ResponseSkillMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseSkillMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseSkillMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseSkillMetadata) MarshalJSON() ([]byte, error) {
	type embed ResponseSkillMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseSkillMetadata) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseSkillMetadataCollectionFieldSuccess = big.NewInt(1 << 0)
	responseSkillMetadataCollectionFieldMessage = big.NewInt(1 << 1)
	responseSkillMetadataCollectionFieldData    = big.NewInt(1 << 2)
)

type ResponseSkillMetadataCollection struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *SkillMetadataCollection `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseSkillMetadataCollection) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseSkillMetadataCollection) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseSkillMetadataCollection) GetData() *SkillMetadataCollection {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseSkillMetadataCollection) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseSkillMetadataCollection) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillMetadataCollection) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseSkillMetadataCollectionFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillMetadataCollection) SetMessage(message *string) {
	r.Message = message
	r.require(responseSkillMetadataCollectionFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillMetadataCollection) SetData(data *SkillMetadataCollection) {
	r.Data = data
	r.require(responseSkillMetadataCollectionFieldData)
}

func (r *ResponseSkillMetadataCollection) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseSkillMetadataCollection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseSkillMetadataCollection(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseSkillMetadataCollection) MarshalJSON() ([]byte, error) {
	type embed ResponseSkillMetadataCollection
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseSkillMetadataCollection) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseSkillRegistrationResultFieldSuccess = big.NewInt(1 << 0)
	responseSkillRegistrationResultFieldMessage = big.NewInt(1 << 1)
	responseSkillRegistrationResultFieldData    = big.NewInt(1 << 2)
)

type ResponseSkillRegistrationResult struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *SkillRegistrationResult `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseSkillRegistrationResult) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseSkillRegistrationResult) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseSkillRegistrationResult) GetData() *SkillRegistrationResult {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseSkillRegistrationResult) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseSkillRegistrationResult) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillRegistrationResult) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseSkillRegistrationResultFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillRegistrationResult) SetMessage(message *string) {
	r.Message = message
	r.require(responseSkillRegistrationResultFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseSkillRegistrationResult) SetData(data *SkillRegistrationResult) {
	r.Data = data
	r.require(responseSkillRegistrationResultFieldData)
}

func (r *ResponseSkillRegistrationResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseSkillRegistrationResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseSkillRegistrationResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseSkillRegistrationResult) MarshalJSON() ([]byte, error) {
	type embed ResponseSkillRegistrationResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseSkillRegistrationResult) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	skillContentResultFieldName    = big.NewInt(1 << 0)
	skillContentResultFieldPath    = big.NewInt(1 << 1)
	skillContentResultFieldContent = big.NewInt(1 << 2)
)

type SkillContentResult struct {
	// Skill name
	Name string `json:"name" url:"name"`
	// Absolute path to the skill directory
	Path string `json:"path" url:"path"`
	// Skill content excluding front matter
	Content string `json:"content" url:"content"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SkillContentResult) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SkillContentResult) GetPath() string {
	if s == nil {
		return ""
	}
	return s.Path
}

func (s *SkillContentResult) GetContent() string {
	if s == nil {
		return ""
	}
	return s.Content
}

func (s *SkillContentResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SkillContentResult) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillContentResult) SetName(name string) {
	s.Name = name
	s.require(skillContentResultFieldName)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillContentResult) SetPath(path string) {
	s.Path = path
	s.require(skillContentResultFieldPath)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillContentResult) SetContent(content string) {
	s.Content = content
	s.require(skillContentResultFieldContent)
}

func (s *SkillContentResult) UnmarshalJSON(data []byte) error {
	type unmarshaler SkillContentResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SkillContentResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SkillContentResult) MarshalJSON() ([]byte, error) {
	type embed SkillContentResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SkillContentResult) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	skillMetadataFieldName               = big.NewInt(1 << 0)
	skillMetadataFieldPath               = big.NewInt(1 << 1)
	skillMetadataFieldMetadata           = big.NewInt(1 << 2)
	skillMetadataFieldDependencyCommands = big.NewInt(1 << 3)
)

type SkillMetadata struct {
	// Skill name
	Name string `json:"name" url:"name"`
	// Absolute path to the skill directory
	Path string `json:"path" url:"path"`
	// Metadata parsed from SKILL.md front matter
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Dependency commands for the skill
	DependencyCommands []*DependencyCommandResult `json:"dependency_commands,omitempty" url:"dependency_commands,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SkillMetadata) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SkillMetadata) GetPath() string {
	if s == nil {
		return ""
	}
	return s.Path
}

func (s *SkillMetadata) GetMetadata() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *SkillMetadata) GetDependencyCommands() []*DependencyCommandResult {
	if s == nil {
		return nil
	}
	return s.DependencyCommands
}

func (s *SkillMetadata) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SkillMetadata) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillMetadata) SetName(name string) {
	s.Name = name
	s.require(skillMetadataFieldName)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillMetadata) SetPath(path string) {
	s.Path = path
	s.require(skillMetadataFieldPath)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillMetadata) SetMetadata(metadata map[string]interface{}) {
	s.Metadata = metadata
	s.require(skillMetadataFieldMetadata)
}

// SetDependencyCommands sets the DependencyCommands field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillMetadata) SetDependencyCommands(dependencyCommands []*DependencyCommandResult) {
	s.DependencyCommands = dependencyCommands
	s.require(skillMetadataFieldDependencyCommands)
}

func (s *SkillMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler SkillMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SkillMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SkillMetadata) MarshalJSON() ([]byte, error) {
	type embed SkillMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SkillMetadata) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	skillMetadataCollectionFieldSkills = big.NewInt(1 << 0)
)

type SkillMetadataCollection struct {
	// Collection of skill metadata entries
	Skills []*SkillMetadata `json:"skills,omitempty" url:"skills,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SkillMetadataCollection) GetSkills() []*SkillMetadata {
	if s == nil {
		return nil
	}
	return s.Skills
}

func (s *SkillMetadataCollection) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SkillMetadataCollection) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSkills sets the Skills field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillMetadataCollection) SetSkills(skills []*SkillMetadata) {
	s.Skills = skills
	s.require(skillMetadataCollectionFieldSkills)
}

func (s *SkillMetadataCollection) UnmarshalJSON(data []byte) error {
	type unmarshaler SkillMetadataCollection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SkillMetadataCollection(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SkillMetadataCollection) MarshalJSON() ([]byte, error) {
	type embed SkillMetadataCollection
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SkillMetadataCollection) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	skillRegistrationResultFieldCount      = big.NewInt(1 << 0)
	skillRegistrationResultFieldRegistered = big.NewInt(1 << 1)
)

type SkillRegistrationResult struct {
	// Number of registered skills
	Count int `json:"count" url:"count"`
	// Registered skills and metadata
	Registered []*SkillMetadata `json:"registered,omitempty" url:"registered,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SkillRegistrationResult) GetCount() int {
	if s == nil {
		return 0
	}
	return s.Count
}

func (s *SkillRegistrationResult) GetRegistered() []*SkillMetadata {
	if s == nil {
		return nil
	}
	return s.Registered
}

func (s *SkillRegistrationResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SkillRegistrationResult) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillRegistrationResult) SetCount(count int) {
	s.Count = count
	s.require(skillRegistrationResultFieldCount)
}

// SetRegistered sets the Registered field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SkillRegistrationResult) SetRegistered(registered []*SkillMetadata) {
	s.Registered = registered
	s.require(skillRegistrationResultFieldRegistered)
}

func (s *SkillRegistrationResult) UnmarshalJSON(data []byte) error {
	type unmarshaler SkillRegistrationResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SkillRegistrationResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SkillRegistrationResult) MarshalJSON() ([]byte, error) {
	type embed SkillRegistrationResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SkillRegistrationResult) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
