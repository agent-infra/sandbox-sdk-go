// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
	big "math/big"
)

var (
	codeExecuteRequestFieldLanguage = big.NewInt(1 << 0)
	codeExecuteRequestFieldCode     = big.NewInt(1 << 1)
	codeExecuteRequestFieldTimeout  = big.NewInt(1 << 2)
)

type CodeExecuteRequest struct {
	// Target runtime language
	Language Language `json:"language" url:"-"`
	// Source code to execute
	Code string `json:"code" url:"-"`
	// Execution timeout in seconds
	Timeout *int `json:"timeout,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CodeExecuteRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteRequest) SetLanguage(language Language) {
	c.Language = language
	c.require(codeExecuteRequestFieldLanguage)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteRequest) SetCode(code string) {
	c.Code = code
	c.require(codeExecuteRequestFieldCode)
}

// SetTimeout sets the Timeout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteRequest) SetTimeout(timeout *int) {
	c.Timeout = timeout
	c.require(codeExecuteRequestFieldTimeout)
}

// Unified code execution response model
var (
	codeExecuteResponseFieldLanguage = big.NewInt(1 << 0)
	codeExecuteResponseFieldStatus   = big.NewInt(1 << 1)
	codeExecuteResponseFieldOutputs  = big.NewInt(1 << 2)
	codeExecuteResponseFieldCode     = big.NewInt(1 << 3)
	codeExecuteResponseFieldStdout   = big.NewInt(1 << 4)
	codeExecuteResponseFieldStderr   = big.NewInt(1 << 5)
	codeExecuteResponseFieldExitCode = big.NewInt(1 << 6)
)

type CodeExecuteResponse struct {
	// Runtime language that executed the code
	Language Language `json:"language" url:"language"`
	// Execution status indicator
	Status string `json:"status" url:"status"`
	// Structured execution outputs
	Outputs []map[string]interface{} `json:"outputs,omitempty" url:"outputs,omitempty"`
	// Echo of executed code
	Code string `json:"code" url:"code"`
	// Captured standard output stream
	Stdout *string `json:"stdout,omitempty" url:"stdout,omitempty"`
	// Captured standard error stream
	Stderr *string `json:"stderr,omitempty" url:"stderr,omitempty"`
	// Process exit code when applicable
	ExitCode *int `json:"exit_code,omitempty" url:"exit_code,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CodeExecuteResponse) GetLanguage() Language {
	if c == nil {
		return ""
	}
	return c.Language
}

func (c *CodeExecuteResponse) GetStatus() string {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *CodeExecuteResponse) GetOutputs() []map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Outputs
}

func (c *CodeExecuteResponse) GetCode() string {
	if c == nil {
		return ""
	}
	return c.Code
}

func (c *CodeExecuteResponse) GetStdout() *string {
	if c == nil {
		return nil
	}
	return c.Stdout
}

func (c *CodeExecuteResponse) GetStderr() *string {
	if c == nil {
		return nil
	}
	return c.Stderr
}

func (c *CodeExecuteResponse) GetExitCode() *int {
	if c == nil {
		return nil
	}
	return c.ExitCode
}

func (c *CodeExecuteResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodeExecuteResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteResponse) SetLanguage(language Language) {
	c.Language = language
	c.require(codeExecuteResponseFieldLanguage)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteResponse) SetStatus(status string) {
	c.Status = status
	c.require(codeExecuteResponseFieldStatus)
}

// SetOutputs sets the Outputs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteResponse) SetOutputs(outputs []map[string]interface{}) {
	c.Outputs = outputs
	c.require(codeExecuteResponseFieldOutputs)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteResponse) SetCode(code string) {
	c.Code = code
	c.require(codeExecuteResponseFieldCode)
}

// SetStdout sets the Stdout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteResponse) SetStdout(stdout *string) {
	c.Stdout = stdout
	c.require(codeExecuteResponseFieldStdout)
}

// SetStderr sets the Stderr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteResponse) SetStderr(stderr *string) {
	c.Stderr = stderr
	c.require(codeExecuteResponseFieldStderr)
}

// SetExitCode sets the ExitCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeExecuteResponse) SetExitCode(exitCode *int) {
	c.ExitCode = exitCode
	c.require(codeExecuteResponseFieldExitCode)
}

func (c *CodeExecuteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CodeExecuteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodeExecuteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodeExecuteResponse) MarshalJSON() ([]byte, error) {
	type embed CodeExecuteResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CodeExecuteResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Unified code information response
var (
	codeInfoResponseFieldLanguages = big.NewInt(1 << 0)
)

type CodeInfoResponse struct {
	// List of supported languages and metadata
	Languages []*CodeLanguageInfo `json:"languages" url:"languages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CodeInfoResponse) GetLanguages() []*CodeLanguageInfo {
	if c == nil {
		return nil
	}
	return c.Languages
}

func (c *CodeInfoResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodeInfoResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetLanguages sets the Languages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeInfoResponse) SetLanguages(languages []*CodeLanguageInfo) {
	c.Languages = languages
	c.require(codeInfoResponseFieldLanguages)
}

func (c *CodeInfoResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CodeInfoResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodeInfoResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodeInfoResponse) MarshalJSON() ([]byte, error) {
	type embed CodeInfoResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CodeInfoResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Metadata about a supported code runtime
var (
	codeLanguageInfoFieldLanguage       = big.NewInt(1 << 0)
	codeLanguageInfoFieldDescription    = big.NewInt(1 << 1)
	codeLanguageInfoFieldRuntimeVersion = big.NewInt(1 << 2)
	codeLanguageInfoFieldDefaultTimeout = big.NewInt(1 << 3)
	codeLanguageInfoFieldMaxTimeout     = big.NewInt(1 << 4)
	codeLanguageInfoFieldDetails        = big.NewInt(1 << 5)
)

type CodeLanguageInfo struct {
	// Supported language identifier
	Language Language `json:"language" url:"language"`
	// Human readable runtime description
	Description string `json:"description" url:"description"`
	// Primary runtime version identifier
	RuntimeVersion *string `json:"runtime_version,omitempty" url:"runtime_version,omitempty"`
	// Default timeout in seconds
	DefaultTimeout *int `json:"default_timeout,omitempty" url:"default_timeout,omitempty"`
	// Maximum allowed timeout in seconds
	MaxTimeout *int `json:"max_timeout,omitempty" url:"max_timeout,omitempty"`
	// Additional runtime specific metadata
	Details map[string]interface{} `json:"details,omitempty" url:"details,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CodeLanguageInfo) GetLanguage() Language {
	if c == nil {
		return ""
	}
	return c.Language
}

func (c *CodeLanguageInfo) GetDescription() string {
	if c == nil {
		return ""
	}
	return c.Description
}

func (c *CodeLanguageInfo) GetRuntimeVersion() *string {
	if c == nil {
		return nil
	}
	return c.RuntimeVersion
}

func (c *CodeLanguageInfo) GetDefaultTimeout() *int {
	if c == nil {
		return nil
	}
	return c.DefaultTimeout
}

func (c *CodeLanguageInfo) GetMaxTimeout() *int {
	if c == nil {
		return nil
	}
	return c.MaxTimeout
}

func (c *CodeLanguageInfo) GetDetails() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Details
}

func (c *CodeLanguageInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodeLanguageInfo) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeLanguageInfo) SetLanguage(language Language) {
	c.Language = language
	c.require(codeLanguageInfoFieldLanguage)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeLanguageInfo) SetDescription(description string) {
	c.Description = description
	c.require(codeLanguageInfoFieldDescription)
}

// SetRuntimeVersion sets the RuntimeVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeLanguageInfo) SetRuntimeVersion(runtimeVersion *string) {
	c.RuntimeVersion = runtimeVersion
	c.require(codeLanguageInfoFieldRuntimeVersion)
}

// SetDefaultTimeout sets the DefaultTimeout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeLanguageInfo) SetDefaultTimeout(defaultTimeout *int) {
	c.DefaultTimeout = defaultTimeout
	c.require(codeLanguageInfoFieldDefaultTimeout)
}

// SetMaxTimeout sets the MaxTimeout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeLanguageInfo) SetMaxTimeout(maxTimeout *int) {
	c.MaxTimeout = maxTimeout
	c.require(codeLanguageInfoFieldMaxTimeout)
}

// SetDetails sets the Details field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CodeLanguageInfo) SetDetails(details map[string]interface{}) {
	c.Details = details
	c.require(codeLanguageInfoFieldDetails)
}

func (c *CodeLanguageInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CodeLanguageInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodeLanguageInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodeLanguageInfo) MarshalJSON() ([]byte, error) {
	type embed CodeLanguageInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CodeLanguageInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Supported programming languages for code execution
type Language string

const (
	LanguagePython     Language = "python"
	LanguageJavascript Language = "javascript"
)

func NewLanguageFromString(s string) (Language, error) {
	switch s {
	case "python":
		return LanguagePython, nil
	case "javascript":
		return LanguageJavascript, nil
	}
	var t Language
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l Language) Ptr() *Language {
	return &l
}

var (
	responseCodeExecuteResponseFieldSuccess = big.NewInt(1 << 0)
	responseCodeExecuteResponseFieldMessage = big.NewInt(1 << 1)
	responseCodeExecuteResponseFieldData    = big.NewInt(1 << 2)
)

type ResponseCodeExecuteResponse struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *CodeExecuteResponse `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseCodeExecuteResponse) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseCodeExecuteResponse) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseCodeExecuteResponse) GetData() *CodeExecuteResponse {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseCodeExecuteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseCodeExecuteResponse) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCodeExecuteResponse) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseCodeExecuteResponseFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCodeExecuteResponse) SetMessage(message *string) {
	r.Message = message
	r.require(responseCodeExecuteResponseFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCodeExecuteResponse) SetData(data *CodeExecuteResponse) {
	r.Data = data
	r.require(responseCodeExecuteResponseFieldData)
}

func (r *ResponseCodeExecuteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseCodeExecuteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseCodeExecuteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseCodeExecuteResponse) MarshalJSON() ([]byte, error) {
	type embed ResponseCodeExecuteResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseCodeExecuteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseCodeInfoResponseFieldSuccess = big.NewInt(1 << 0)
	responseCodeInfoResponseFieldMessage = big.NewInt(1 << 1)
	responseCodeInfoResponseFieldData    = big.NewInt(1 << 2)
)

type ResponseCodeInfoResponse struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *CodeInfoResponse `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseCodeInfoResponse) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseCodeInfoResponse) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseCodeInfoResponse) GetData() *CodeInfoResponse {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseCodeInfoResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseCodeInfoResponse) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCodeInfoResponse) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseCodeInfoResponseFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCodeInfoResponse) SetMessage(message *string) {
	r.Message = message
	r.require(responseCodeInfoResponseFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseCodeInfoResponse) SetData(data *CodeInfoResponse) {
	r.Data = data
	r.require(responseCodeInfoResponseFieldData)
}

func (r *ResponseCodeInfoResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseCodeInfoResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseCodeInfoResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseCodeInfoResponse) MarshalJSON() ([]byte, error) {
	type embed ResponseCodeInfoResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseCodeInfoResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
