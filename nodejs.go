// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/agent-infra/sandbox-sdk-go/internal"
	big "math/big"
)

var (
	nodeJsExecuteRequestFieldCode    = big.NewInt(1 << 0)
	nodeJsExecuteRequestFieldTimeout = big.NewInt(1 << 1)
	nodeJsExecuteRequestFieldStdin   = big.NewInt(1 << 2)
	nodeJsExecuteRequestFieldFiles   = big.NewInt(1 << 3)
)

type NodeJsExecuteRequest struct {
	// JavaScript code to execute
	Code string `json:"code" url:"-"`
	// Execution timeout in seconds
	Timeout *int `json:"timeout,omitempty" url:"-"`
	// Standard input for the process
	Stdin *string `json:"stdin,omitempty" url:"-"`
	// Additional files to create in execution directory
	Files map[string]*string `json:"files,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (n *NodeJsExecuteRequest) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteRequest) SetCode(code string) {
	n.Code = code
	n.require(nodeJsExecuteRequestFieldCode)
}

// SetTimeout sets the Timeout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteRequest) SetTimeout(timeout *int) {
	n.Timeout = timeout
	n.require(nodeJsExecuteRequestFieldTimeout)
}

// SetStdin sets the Stdin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteRequest) SetStdin(stdin *string) {
	n.Stdin = stdin
	n.require(nodeJsExecuteRequestFieldStdin)
}

// SetFiles sets the Files field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteRequest) SetFiles(files map[string]*string) {
	n.Files = files
	n.require(nodeJsExecuteRequestFieldFiles)
}

var (
	nodeJsExecuteResponseFieldStatus         = big.NewInt(1 << 0)
	nodeJsExecuteResponseFieldExecutionCount = big.NewInt(1 << 1)
	nodeJsExecuteResponseFieldOutputs        = big.NewInt(1 << 2)
	nodeJsExecuteResponseFieldCode           = big.NewInt(1 << 3)
	nodeJsExecuteResponseFieldStdout         = big.NewInt(1 << 4)
	nodeJsExecuteResponseFieldStderr         = big.NewInt(1 << 5)
	nodeJsExecuteResponseFieldExitCode       = big.NewInt(1 << 6)
)

type NodeJsExecuteResponse struct {
	// Language that was executed (always 'javascript')
	// Execution status: ok, error, or timeout
	Status string `json:"status" url:"status"`
	// Execution count
	ExecutionCount *int `json:"execution_count,omitempty" url:"execution_count,omitempty"`
	// List of execution outputs
	Outputs []*NodeJsOutput `json:"outputs,omitempty" url:"outputs,omitempty"`
	// Code that was executed
	Code string `json:"code" url:"code"`
	// Standard output
	Stdout *string `json:"stdout,omitempty" url:"stdout,omitempty"`
	// Standard error
	Stderr *string `json:"stderr,omitempty" url:"stderr,omitempty"`
	// Process exit code
	ExitCode int `json:"exit_code" url:"exit_code"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	language       string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NodeJsExecuteResponse) GetStatus() string {
	if n == nil {
		return ""
	}
	return n.Status
}

func (n *NodeJsExecuteResponse) GetExecutionCount() *int {
	if n == nil {
		return nil
	}
	return n.ExecutionCount
}

func (n *NodeJsExecuteResponse) GetOutputs() []*NodeJsOutput {
	if n == nil {
		return nil
	}
	return n.Outputs
}

func (n *NodeJsExecuteResponse) GetCode() string {
	if n == nil {
		return ""
	}
	return n.Code
}

func (n *NodeJsExecuteResponse) GetStdout() *string {
	if n == nil {
		return nil
	}
	return n.Stdout
}

func (n *NodeJsExecuteResponse) GetStderr() *string {
	if n == nil {
		return nil
	}
	return n.Stderr
}

func (n *NodeJsExecuteResponse) GetExitCode() int {
	if n == nil {
		return 0
	}
	return n.ExitCode
}

func (n *NodeJsExecuteResponse) Language() string {
	return n.language
}

func (n *NodeJsExecuteResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NodeJsExecuteResponse) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteResponse) SetStatus(status string) {
	n.Status = status
	n.require(nodeJsExecuteResponseFieldStatus)
}

// SetExecutionCount sets the ExecutionCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteResponse) SetExecutionCount(executionCount *int) {
	n.ExecutionCount = executionCount
	n.require(nodeJsExecuteResponseFieldExecutionCount)
}

// SetOutputs sets the Outputs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteResponse) SetOutputs(outputs []*NodeJsOutput) {
	n.Outputs = outputs
	n.require(nodeJsExecuteResponseFieldOutputs)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteResponse) SetCode(code string) {
	n.Code = code
	n.require(nodeJsExecuteResponseFieldCode)
}

// SetStdout sets the Stdout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteResponse) SetStdout(stdout *string) {
	n.Stdout = stdout
	n.require(nodeJsExecuteResponseFieldStdout)
}

// SetStderr sets the Stderr field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteResponse) SetStderr(stderr *string) {
	n.Stderr = stderr
	n.require(nodeJsExecuteResponseFieldStderr)
}

// SetExitCode sets the ExitCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsExecuteResponse) SetExitCode(exitCode int) {
	n.ExitCode = exitCode
	n.require(nodeJsExecuteResponseFieldExitCode)
}

func (n *NodeJsExecuteResponse) UnmarshalJSON(data []byte) error {
	type embed NodeJsExecuteResponse
	var unmarshaler = struct {
		embed
		Language string `json:"language"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NodeJsExecuteResponse(unmarshaler.embed)
	if unmarshaler.Language != "javascript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "javascript", unmarshaler.Language)
	}
	n.language = unmarshaler.Language
	extraProperties, err := internal.ExtractExtraProperties(data, *n, "language")
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NodeJsExecuteResponse) MarshalJSON() ([]byte, error) {
	type embed NodeJsExecuteResponse
	var marshaler = struct {
		embed
		Language string `json:"language"`
	}{
		embed:    embed(*n),
		Language: "javascript",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NodeJsExecuteResponse) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	nodeJsOutputFieldOutputType = big.NewInt(1 << 0)
	nodeJsOutputFieldName       = big.NewInt(1 << 1)
	nodeJsOutputFieldText       = big.NewInt(1 << 2)
	nodeJsOutputFieldEname      = big.NewInt(1 << 3)
	nodeJsOutputFieldEvalue     = big.NewInt(1 << 4)
	nodeJsOutputFieldTraceback  = big.NewInt(1 << 5)
	nodeJsOutputFieldData       = big.NewInt(1 << 6)
	nodeJsOutputFieldMetadata   = big.NewInt(1 << 7)
)

type NodeJsOutput struct {
	// Type of output: stream, error, or execute_result
	OutputType string `json:"output_type" url:"output_type"`
	// Stream name (stdout/stderr) for stream outputs
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Text content for stream outputs
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// Error name for error outputs
	Ename *string `json:"ename,omitempty" url:"ename,omitempty"`
	// Error value for error outputs
	Evalue *string `json:"evalue,omitempty" url:"evalue,omitempty"`
	// Error traceback for error outputs
	Traceback []string `json:"traceback,omitempty" url:"traceback,omitempty"`
	// Data for execute_result outputs
	Data map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Metadata for outputs
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NodeJsOutput) GetOutputType() string {
	if n == nil {
		return ""
	}
	return n.OutputType
}

func (n *NodeJsOutput) GetName() *string {
	if n == nil {
		return nil
	}
	return n.Name
}

func (n *NodeJsOutput) GetText() *string {
	if n == nil {
		return nil
	}
	return n.Text
}

func (n *NodeJsOutput) GetEname() *string {
	if n == nil {
		return nil
	}
	return n.Ename
}

func (n *NodeJsOutput) GetEvalue() *string {
	if n == nil {
		return nil
	}
	return n.Evalue
}

func (n *NodeJsOutput) GetTraceback() []string {
	if n == nil {
		return nil
	}
	return n.Traceback
}

func (n *NodeJsOutput) GetData() map[string]interface{} {
	if n == nil {
		return nil
	}
	return n.Data
}

func (n *NodeJsOutput) GetMetadata() map[string]interface{} {
	if n == nil {
		return nil
	}
	return n.Metadata
}

func (n *NodeJsOutput) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NodeJsOutput) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetOutputType sets the OutputType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetOutputType(outputType string) {
	n.OutputType = outputType
	n.require(nodeJsOutputFieldOutputType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetName(name *string) {
	n.Name = name
	n.require(nodeJsOutputFieldName)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetText(text *string) {
	n.Text = text
	n.require(nodeJsOutputFieldText)
}

// SetEname sets the Ename field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetEname(ename *string) {
	n.Ename = ename
	n.require(nodeJsOutputFieldEname)
}

// SetEvalue sets the Evalue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetEvalue(evalue *string) {
	n.Evalue = evalue
	n.require(nodeJsOutputFieldEvalue)
}

// SetTraceback sets the Traceback field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetTraceback(traceback []string) {
	n.Traceback = traceback
	n.require(nodeJsOutputFieldTraceback)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetData(data map[string]interface{}) {
	n.Data = data
	n.require(nodeJsOutputFieldData)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsOutput) SetMetadata(metadata map[string]interface{}) {
	n.Metadata = metadata
	n.require(nodeJsOutputFieldMetadata)
}

func (n *NodeJsOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler NodeJsOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NodeJsOutput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NodeJsOutput) MarshalJSON() ([]byte, error) {
	type embed NodeJsOutput
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NodeJsOutput) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NodeJS runtime information model
var (
	nodeJsRuntimeInfoFieldNodeVersion        = big.NewInt(1 << 0)
	nodeJsRuntimeInfoFieldNpmVersion         = big.NewInt(1 << 1)
	nodeJsRuntimeInfoFieldSupportedLanguages = big.NewInt(1 << 2)
	nodeJsRuntimeInfoFieldDescription        = big.NewInt(1 << 3)
	nodeJsRuntimeInfoFieldRuntimeDirectory   = big.NewInt(1 << 4)
	nodeJsRuntimeInfoFieldError              = big.NewInt(1 << 5)
)

type NodeJsRuntimeInfo struct {
	// Node.js version
	NodeVersion string `json:"node_version" url:"node_version"`
	// npm version
	NpmVersion string `json:"npm_version" url:"npm_version"`
	// List of supported languages
	SupportedLanguages []string `json:"supported_languages" url:"supported_languages"`
	// Service description
	Description string `json:"description" url:"description"`
	// Runtime directory path
	RuntimeDirectory *string `json:"runtime_directory,omitempty" url:"runtime_directory,omitempty"`
	// Error message if runtime info retrieval failed
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NodeJsRuntimeInfo) GetNodeVersion() string {
	if n == nil {
		return ""
	}
	return n.NodeVersion
}

func (n *NodeJsRuntimeInfo) GetNpmVersion() string {
	if n == nil {
		return ""
	}
	return n.NpmVersion
}

func (n *NodeJsRuntimeInfo) GetSupportedLanguages() []string {
	if n == nil {
		return nil
	}
	return n.SupportedLanguages
}

func (n *NodeJsRuntimeInfo) GetDescription() string {
	if n == nil {
		return ""
	}
	return n.Description
}

func (n *NodeJsRuntimeInfo) GetRuntimeDirectory() *string {
	if n == nil {
		return nil
	}
	return n.RuntimeDirectory
}

func (n *NodeJsRuntimeInfo) GetError() *string {
	if n == nil {
		return nil
	}
	return n.Error
}

func (n *NodeJsRuntimeInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NodeJsRuntimeInfo) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetNodeVersion sets the NodeVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsRuntimeInfo) SetNodeVersion(nodeVersion string) {
	n.NodeVersion = nodeVersion
	n.require(nodeJsRuntimeInfoFieldNodeVersion)
}

// SetNpmVersion sets the NpmVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsRuntimeInfo) SetNpmVersion(npmVersion string) {
	n.NpmVersion = npmVersion
	n.require(nodeJsRuntimeInfoFieldNpmVersion)
}

// SetSupportedLanguages sets the SupportedLanguages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsRuntimeInfo) SetSupportedLanguages(supportedLanguages []string) {
	n.SupportedLanguages = supportedLanguages
	n.require(nodeJsRuntimeInfoFieldSupportedLanguages)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsRuntimeInfo) SetDescription(description string) {
	n.Description = description
	n.require(nodeJsRuntimeInfoFieldDescription)
}

// SetRuntimeDirectory sets the RuntimeDirectory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsRuntimeInfo) SetRuntimeDirectory(runtimeDirectory *string) {
	n.RuntimeDirectory = runtimeDirectory
	n.require(nodeJsRuntimeInfoFieldRuntimeDirectory)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NodeJsRuntimeInfo) SetError(error_ *string) {
	n.Error = error_
	n.require(nodeJsRuntimeInfoFieldError)
}

func (n *NodeJsRuntimeInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NodeJsRuntimeInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NodeJsRuntimeInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NodeJsRuntimeInfo) MarshalJSON() ([]byte, error) {
	type embed NodeJsRuntimeInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NodeJsRuntimeInfo) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	responseNodeJsExecuteResponseFieldSuccess = big.NewInt(1 << 0)
	responseNodeJsExecuteResponseFieldMessage = big.NewInt(1 << 1)
	responseNodeJsExecuteResponseFieldData    = big.NewInt(1 << 2)
)

type ResponseNodeJsExecuteResponse struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *NodeJsExecuteResponse `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseNodeJsExecuteResponse) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseNodeJsExecuteResponse) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseNodeJsExecuteResponse) GetData() *NodeJsExecuteResponse {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseNodeJsExecuteResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseNodeJsExecuteResponse) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseNodeJsExecuteResponse) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseNodeJsExecuteResponseFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseNodeJsExecuteResponse) SetMessage(message *string) {
	r.Message = message
	r.require(responseNodeJsExecuteResponseFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseNodeJsExecuteResponse) SetData(data *NodeJsExecuteResponse) {
	r.Data = data
	r.require(responseNodeJsExecuteResponseFieldData)
}

func (r *ResponseNodeJsExecuteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseNodeJsExecuteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseNodeJsExecuteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseNodeJsExecuteResponse) MarshalJSON() ([]byte, error) {
	type embed ResponseNodeJsExecuteResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseNodeJsExecuteResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseNodeJsRuntimeInfoFieldSuccess = big.NewInt(1 << 0)
	responseNodeJsRuntimeInfoFieldMessage = big.NewInt(1 << 1)
	responseNodeJsRuntimeInfoFieldData    = big.NewInt(1 << 2)
)

type ResponseNodeJsRuntimeInfo struct {
	// Whether the operation was successful
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Operation result message
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Data returned from the operation
	Data *NodeJsRuntimeInfo `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseNodeJsRuntimeInfo) GetSuccess() *bool {
	if r == nil {
		return nil
	}
	return r.Success
}

func (r *ResponseNodeJsRuntimeInfo) GetMessage() *string {
	if r == nil {
		return nil
	}
	return r.Message
}

func (r *ResponseNodeJsRuntimeInfo) GetData() *NodeJsRuntimeInfo {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *ResponseNodeJsRuntimeInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseNodeJsRuntimeInfo) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseNodeJsRuntimeInfo) SetSuccess(success *bool) {
	r.Success = success
	r.require(responseNodeJsRuntimeInfoFieldSuccess)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseNodeJsRuntimeInfo) SetMessage(message *string) {
	r.Message = message
	r.require(responseNodeJsRuntimeInfoFieldMessage)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseNodeJsRuntimeInfo) SetData(data *NodeJsRuntimeInfo) {
	r.Data = data
	r.require(responseNodeJsRuntimeInfoFieldData)
}

func (r *ResponseNodeJsRuntimeInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseNodeJsRuntimeInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseNodeJsRuntimeInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseNodeJsRuntimeInfo) MarshalJSON() ([]byte, error) {
	type embed ResponseNodeJsRuntimeInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseNodeJsRuntimeInfo) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
